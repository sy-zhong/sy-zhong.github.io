<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 372C 单调队列优化dp]]></title>
    <url>%2F2018%2F10%2F24%2FpoCodeForces-372C-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[第二道 单调dp题单调队列只是辅助，dp是关键，写出合理的dp方程才知道并用单调队列优化。大意：1-n 个地点 ，放m次烟花 ，每次可走d的长度 （可以不是必须）给出m次烟花的参数a[i] —-烟花地点 b[i]—第i次烟花的一个参数，没什么实际意义 t[i]—-燃放烟花的时间每放一次烟花，这个人就会得到 bi - |ai - x| 的权值 x是当时的位置给出状态方程：dp[i][j]：第i次燃放烟花时，且人在j 时的最大值。 dp[i][j] 可以转移到什么状态 ——&gt; dp[i+1][k]dp[i][j] = max(dp[i][k]) + b[i] -|a[i]-j|就是说 我现在可以从k 的位置走到 j，并加上相应的权值。那么k会受到 t[i] -t[i-1] 和 d 的限制限制是什么？$\Delta t = t_i - t_{i-1}$$ k \epsilon \left [ max(0,j-\Delta t d) ,min(n,j+\Delta t d)\right ] $ dp[i][j] = max(dp[i-1][k]) + b[i] - |a[i]-j|搞清楚了状态转移方程和一些细节问题，怎么优化呢？]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树分治———点分治]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%A0%91%E5%88%86%E6%B2%BB%E2%80%94%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[树分治———点分治点分治还是很有意思的，不过自己看博客还是比较吃力的，看了好久。基本思想：找一颗树上的重心（所有以此点为根的子树中最大子树最小的那个根结点）分治解决。（这是关键。）详细解释一下：一开始结点数为n，朴素算法O($n^2$)，若找重心分治处理就是O($log(n)$)层，每次合并时间是（这里是O(nlog(n)+n) 排序+找最远可行对）不定。那最终就是O(nlog(n)log(n)).最终的决定权基本在合并算法的手里，能合并，就能处理。需要注意的是1ans-=solve(v,w); 要减掉没有经过根的点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=40010;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top]=Edge&#123;c,b,head[a]&#125;; head[a]=top++;&#125;void init()&#123; top=0; memset(head,-1,sizeof(head));&#125;int k;int root,sim[N],S,mxson[N];int MX,vis[N];void getroot(int u,int fa)&#123; sim[u]=1;mxson[u]=0; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int w=edge[i].val; if(v==fa||vis[v]) continue; getroot(v,u); sim[u]+=sim[v]; mxson[u]=max(mxson[u],sim[v]); &#125; mxson[u] = max(mxson[u],S-sim[u]); if(mxson[u]&lt;MX)&#123; MX=mxson[u]; root=u; &#125;&#125;LL ans;int id;int dis[N]; //到重心的距离void getdis(int u,int fa,int dist) //点u到root的距离&#123; dis[id++] = dist; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(v==fa||vis[v]) continue; getdis(v,u,dist+w); &#125;&#125;int solve(int u,int len)&#123; //排序找符合的点 id=0; clr(dis,0); getdis(u,0,len); sort(dis,dis+id); int L=0,R=id-1; int tmp=0; while(L&lt;R)&#123; if(dis[R]+dis[L]&lt;=k)&#123;tmp+=R-L;L++;&#125; else R--; &#125; return tmp;&#125;void Divide(int u)&#123; ans+=solve(u,0); vis[u]=true; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(vis[v]) continue; ans-=solve(v,w); S=sim[v];root=0; MX=INF;getroot(v,0); Divide(root); &#125;&#125;int main()&#123; int n; while(scanf("%d%d",&amp;n,&amp;k),n+k)&#123; init(); int a,b,c; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); addedge(b,a,c); &#125; clr(vis,0); S=n,MX=INF; root=0;ans=0; getroot(1,0); Divide(root); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>分治</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下界网络流]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[转载自：https://www.cnblogs.com/mlystdcall/p/6734852.html【教程】上下界网络流建模方法总结前言 之前学习上下界网络流的时候，花了很多时间去理解建模的方式和原理，然而今天复习的时候发现忘得差不多了QwQ。于是参考了一下以前的代码，再次做了个总结，放在博客里，省得以后忘掉QwQ。 无源汇可行流 建模方法： 首先建立一个源ss和一个汇tt，一般称为附加源和附加汇。 对于图中的每条弧，假设它容量上界为c，下界b，那么把这条边拆为三条只有上界的弧。 一条为，容量为b； 一条为，容量为b； 一条为，容量为c−b。 其中前两条弧一般称为附加弧。 然后对这张图跑最大流，以ss为源，以tt为汇，如果所有的附加弧都满流，则原图有可行流。 这时，每条非附加弧的流量加上它的容量下界，就是原图中这条弧应该有的流量。 理解方法： 对于原图中的每条弧，我们把c−b称为它的自由流量，意思就是只要它流满了下界，这些流多少都没问题。 既然如此，对于每条弧，我们强制给v提供b单位的流量，并且强制从u那里拿走b单位的流量，这一步对应着两条附加弧。 如果这一系列强制操作能完成的话，也就是有一组可行流了。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。有源汇可行流 建模方法： 建立弧，容量下界为0，上界为∞。 然后对这个新图（实际上只是比原图多了一条边）按照无源汇可行流的方法建模，如果所有附加弧满流，则存在可行流。 求原图中每条边对应的实际流量的方法，同无源汇可行流，只是忽略掉弧就好。 而且这时候弧的流量就是原图的总流量。 理解方法： 有源汇相比无源汇的不同就在于，源和汇是不满足流量平衡的，那么连接之后，源和汇也满足了流量平衡，就可以直接按照无源汇的方式建模。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。有源汇最大流 建模方法： 首先按照有源汇可行流的方法建模，如果不存在可行流，更别提什么最大流了。 如果存在可行流，那么在运行过有源汇可行流的图上（就是已经存在流量的那张图，流量不要清零），跑一遍从s到t的最大流（这里的s和t是原图的源和汇，不是附加源和附加汇），就是原图的最大流。 理解方法： 为什么要在那个已经有了流量的图上跑最大流？因为那张图保证了每条弧的容量下界，在这张图上跑最大流，实际上就是在容量下界全部满足的前提下尽量多得获得“自由流量”。 注意，在这张已经存在流量的图上，弧也是存在流量的，千万不要忽略这条弧。因为它的相反弧的流量为的流量的相反数，且的容量为0，所以这部分的流量也是会被算上的。有源汇最小流 有源汇最小流的常见建模方法比较多，我就只说我常用的一种。 建模方法： 首先按照有源汇可行流的方法建模，但是不要建立这条弧。 然后在这个图上，跑从附加源ss到附加汇tt的最大流。 这时候再添加弧，下界为0，上界为∞。 在现在的这张图上，从ss到tt的最大流，就是原图的最小流。 理解方法： 我们前面提到过，有源汇可行流的流量只是对应一组可行流，并不是最大或者最小流。 并且在跑完有源汇可行流之后，弧的流量就是原图的流量。 从这个角度入手，我们想让弧的流量尽量小，就要尽量多的消耗掉那些“本来不需要经过”的流量。 于是我们在添加之前，跑一遍从ss到tt的最大流，就能尽量多的消耗那些流量啦QwQ。总结 口胡完毕。 我姿势水平不高，没见过什么上下界网络流的题（或许真的不常考？），唯一见过的一道就放上来叭QwQ。题目与题解 Inspection LA 4597 NEERC 2009 题解还请看我的博客QwQ：http://www.cnblogs.com/mlystdcall/p/6734979.html]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流模板]]></title>
    <url>%2F2018%2F10%2F11%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[最大流$O(n^2*\sqrt{v})$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//isap#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAXN = 5010;//点数的最大值const int MAXM = 1e7+10;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear) &#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; int inser; for(int i = 0; i &lt; top; i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow) &#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0; i &lt; top; i++) &#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const int MAXN = 100010;//点数的最大值const int MAXM = 400010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;//加边,单向图三个参数,双向图四个参数void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;//输入参数:起点、终点、点的总数//点的编号没有影响,只要输入点的总数int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; &#125; return ans;&#125; 邻接矩阵，可以跑多次，不用拆图，写起来简单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int MAXN=110;int maze[MAXN][MAXN];int gap[MAXN],dis[MAXN],pre[MAXN],cur[MAXN];int flow[MAXN][MAXN];//存最大流的容量int sap(int start,int end,int nodenum)&#123; memset(cur,0,sizeof(cur)); memset(dis,0,sizeof(dis)); memset(gap,0,sizeof(gap)); memset(flow,0,sizeof(flow)); int u=pre[start]=start,maxflow=0,aug=-1; gap[0]=nodenum; while(dis[start]&lt;nodenum) &#123; loop: for(int v=cur[u]; v&lt;nodenum; v++) if(maze[u][v]-flow[u][v] &amp;&amp; dis[u]==dis[v]+1) &#123; if(aug==-1 || aug&gt;maze[u][v]-flow[u][v])aug=maze[u][v]-flow[u][v]; pre[v]=u; u=cur[u]=v; if(v==end) &#123; maxflow+=aug; for(u=pre[u]; v!=start; v=u,u=pre[u]) &#123; flow[u][v]+=aug; flow[v][u]-=aug; &#125; aug=-1; &#125; goto loop; &#125; int mindis=nodenum-1; for(int v=0; v&lt;nodenum; v++) if(maze[u][v]-flow[u][v]&amp;&amp;mindis&gt;dis[v]) &#123; cur[u]=v; mindis=dis[v]; &#125; if((--gap[dis[u]])==0)break; gap[dis[u]=mindis+1]++; u=pre[u]; &#125; return maxflow;&#125; 最小费用最大流 玄学复杂度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1000;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int MAXM = 100000;const int INF = 0x3f3f3f3f;struct Edge&#123; int to, next, cap, flow, cost;&#125; edge[MAXM];int head[MAXN], tol;int pre[MAXN], dis[MAXN];bool vis[MAXN];int N; //0~N-1的点数void init(int n)&#123; N = n; tol = 0; memset(head, -1, sizeof(head));&#125;void addedge(int u, int v, int cap, int cost)&#123; edge[tol] = Edge&#123;v,head[u],cap,0,cost&#125;; head[u] = tol++; edge[tol] = Edge&#123;u,head[v],0,0,-cost&#125;; head[v] = tol++;&#125;bool spfa(int s, int t)&#123; queue&lt;int&gt; q; for (int i = 0; i &lt; N; i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while (!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if (edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if (!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if (pre[t] == -1) return false; else return true;&#125;int minCostMaxflow(int s, int t, int &amp;cost)&#123; int flow = 0; cost = 0; while (spfa(s, t))&#123; int Min = INF; for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])&#123; if (Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])&#123; edge[i].flow += Min; edge[i ^ 1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3338烦的一比网络流]]></title>
    <url>%2F2018%2F10%2F11%2FHDU-3338%E7%83%A6%E7%9A%84%E4%B8%80%E6%AF%94%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[本来想着要区域赛 就暂时不写题解了。忍不住了，这题踩了太多坑了，状态也不太好，比起做的时间，写题解的时间怎么也不算多。 放两张图片 方便自己看 本质是一个方格填数的题就这么几个格子黑色 不能放值。但他本身可有值左值代表这个点向下直到下个黑点或者边界中的一列白格填的总数为这个左值右值同理这个点向右直到下个黑点或者边界中的一行白格填的总数为这个左值 白色 被填的格子，其他用 这里建图真的是鬼斧神工，根本想不到。首先按行相加的值和按列相加的值肯定是一致的。这里的处理很巧妙从每行到每列建边大概就是这么个意思，自己看的懂就行了。源点连所有的黑点的左半部分（如果有值的话）汇点连所有的黑点的右半部分（如果有值的话） 那么白点怎么处理? 连他左边第一个黑点（有值）和上面第一个黑点（有值），注意拆点，这里就不赘述了。 至于为什么？ 你猜。 tm的200多行，输入有点恶心了。ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAXN = 21000;//点数的最大值const int MAXM = 1e7+10;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear) &#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; int inser; for(int i = 0; i &lt; top; i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow) &#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0; i &lt; top; i++) &#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;int G[110][110][2];//0--下 1--右char tmp[10];int shift(int x)&#123; int s,e; if(x==1) s=0,e=2; else s=4,e=6; int ans=0; for(int i=s;i&lt;=e;i++)&#123; ans=ans*10+tmp[i]-'0'; &#125; return ans;&#125;int n,m;int right(int x,int y)&#123; int i=1; while(y+i&lt;=m &amp;&amp; G[x][y+i][0]==-2)&#123; i++; &#125; return i-1;&#125;int down(int x,int y)&#123; int i=1; while(x+i&lt;=n&amp;&amp;G[x+i][y][0]==-2)&#123; i++; &#125; return i-1;&#125;//int G[MAXN][MAXN][2];//0--下 1--右int upb(int x,int y)&#123; //1 int i=-1; while(x+i&gt;0&amp;&amp;G[x+i][y][0]==-2)&#123; i--; &#125; return x+i;&#125;int leftb(int x,int y)&#123; //0 int i=-1; while(y+i&gt;0&amp;&amp;G[x][y+i][0]==-2)&#123; i--; &#125; return y+i;&#125;void show()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) cout&lt;&lt;G[i][j][0]&lt;&lt;" "&lt;&lt;G[i][j][1]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;//int G[MAXN][MAXN][2];//0--下 1--右int eee(int x,int y)&#123; int pos=(x-1)*m+y; for(int u=head[pos];~u;u=edge[u].next)&#123; return edge[u].flow; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf("%s",tmp); if(tmp[0]=='.') G[i][j][0]=G[i][j][1]=-2; else &#123; if(tmp[0]=='X') G[i][j][0]=-1; else &#123; G[i][j][0]=shift(1); &#125; if(tmp[4]=='X') G[i][j][1]=-1; else G[i][j][1]=shift(0); &#125; &#125; &#125;//先处理权值//源点//汇点 int s=0,e=2*n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]&gt;0)&#123;//是个黑点 G[i][j][0]-=down(i,j); //cout&lt;&lt;G[i][j][0]&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; addedge(n*m+(i-1)*m+j,e,G[i][j][0]); &#125; if(G[i][j][1]&gt;0)&#123;//是个黑点 G[i][j][1]-=right(i,j); //cout&lt;&lt;G[i][j][1]&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; addedge(s,(i-1)*m+j,G[i][j][1]); &#125; &#125;//对白点加边 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]==-2)&#123; int yy=leftb(i,j); int xx=upb(i,j); addedge((i-1)*m+yy,(i-1)*m+j,8); addedge((i-1)*m+j,n*m+(xx-1)*m+j,8); &#125; &#125; int flow=sap(s,e,e+1); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]!=-2) printf("_%c"," \n"[j==m]); if(G[i][j][0]==-2)&#123; printf("%d%c",1+eee(i,j)," \n"[j==m]); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 6386]]></title>
    <url>%2F2018%2F09%2F28%2FHDU-6386%2F</url>
    <content type="text"><![CDATA[dij最短路 + 条件限制这道题很有意思，加深了我对Dij的理解。题意很简单，找一条从1到n的最短路，但若是前一条路和后一条路一致，那么就不计算后一条路，不然不一样了就+1,即边权全是1或0，是0是1取决于前一权值是否和当前权值一致。那么关键点在哪里呢？对于dij堆优化的理解。首先，优先队列里存放的到底是什么？是待选答案。vis数组起到什么作用？区分处理完的集合，和待处理数据的集合。那么优先队列起到的是取出待处理数据中离处理完集合 距离最小的那个。 这看似是非常基础的dij最短路的知识，但在这道题中是一个关键点。 平常dij都有这段1234if(!vis[v]&amp;&amp;dis[v] &gt; w+dis[u])&#123; dis[v] = w+dis[u]; q.push(qnode&#123; v,dis[v]&#125;);&#125; 这里是用以处理好的点的最短路去不停的更新未访问结点的最短路，直到访问过的点的最短路比一个未访问点的最短路长了，那么那个点就一定是到源点的最短路径了（比它短的都更新过它了） 所以存一下边，dij就可以了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=100010;const int M=400010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];struct qnode&#123; int id; int pre; int dis; bool operator &lt;(const qnode &amp;r)const &#123; return dis&gt;r.dis; &#125;&#125;;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,-1,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to,w=edge[i].val; if(!vis[v]&amp;&amp;dis[v]&gt;=dis[u]+(w!=cur.pre))&#123; dis[v]=dis[u]+(w!=cur.pre); q.push(qnode&#123;v,w,(w!=cur.pre) + dis[u]&#125;); &#125; &#125; &#125;&#125;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); int u, v, w; for(int i=1; i&lt;=m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dij(1); if(dis[n] == INF) printf("-1\n"); else printf("%d\n", dis[n]); &#125; return 0;&#125;/*6 61 2 23 6 21 4 34 6 33 6 25 6 2*//*6 61 2 23 6 21 4 34 6 33 6 25 6 2*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路图论模板]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[最短路图论模板 单源最短路dij$O((E+N)logN)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int N=3000;const int M=71000;int n,m;int dis[N];int vis[N];struct edge&#123; int to,v;&#125;;struct qnode&#123; int id; int v; bool operator &lt;(const qnode &amp;r)const &#123; return v&gt;r.v; &#125;&#125;;vector&lt;edge&gt; G[N];void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to,w=G[u][i].v; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(qnode&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//前向星模板 防止类似poj老oj卡vector 一般不用const int N=40010;const int M=150010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];struct qnode&#123; int id; int dis; bool operator &lt;(const qnode &amp;r)const &#123; return dis&gt;r.dis; &#125;&#125;;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to,w=edge[i].val; if(!vis[v]&amp;&amp;dis[v] &gt; w+dis[u])&#123; dis[v] = w+dis[u]; q.push(qnode&#123; v,dis[v]&#125;); &#125; &#125; &#125;&#125; spfa$O(km)$ k最坏情况下是n 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N=10010;const int M=500010;int n,m;int dis[N];struct edge&#123; int to;int v;&#125;;vector&lt;edge&gt; G[N];int vis[N];int cnt[N];//每个点的入队次数void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int cost=G[u][i].v; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859前向星const int N=50010;const int M=50010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];int cnt[N];//每个点的入队次数int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int cost=edge[i].val; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 12345678//读入优化 哎 pojinline LL read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图连通性模板]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%9B%BE%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[有向图强连通缩点所需数组 $idx,low[MAXN],dfn[MAXN]$——————时间戳和两个访问标志$sccno ,scc[MAXN]$ ————点属于哪个连通分支，及连通分量数量$stack st ,inst[MAXN]$————栈，一个中间工具，用于分辨点属于哪个连通分量$vector G[MAXN];$————图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N = 40000;const int M = 500000;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int idx,low[N],dfn[N];int sccno,scc[N];stack&lt;int&gt;st; int inst[N];void tarjan_init()&#123; init(); clr(dfn,0); clr(inst,0); clr(scc,0); sccno=idx=0; while(!st.empty()) st.pop();&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++idx; st.push(x); inst[x]=1; for(int i=head[x];~i;i=edge[i].next) &#123; int v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[x]=min(low[v],low[x]); &#125; else if(inst[v])&#123; low[x]=min(low[x],dfn[v]); &#125; &#125; if(low[x]==dfn[x])&#123; ++sccno; int v; while(1)&#123; v=st.top(); st.pop(); inst[v]=0; scc[v] = sccno; if(x==v) break; &#125; &#125;&#125; 割边&amp;&amp;割点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//割点const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int low[N],dfn[N],idx;int iscut[N];int rootson;void tarjan_init()&#123; init(); clr(dfn,0); idx=rootson=0; clr(iscut,0);&#125;void tarjan(int u,int pre,int id)&#123; dfn[u]=low[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; if(!dfn[v])&#123; tarjan(v,u,i); if(u==1) rootson++; else &#123; low[u]=min(low[u],low[v]); if(low[v]&gt;=dfn[u]) iscut[u]=1; &#125; &#125;else&#123; low[u]= min(low[u],dfn[v]); &#125; &#125;&#125;if(rootson&gt;1) iscut[1]=1;//调用后 加一句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//割边const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int low[N],dfn[N],idx;int fa[N],isbridge[N];int bridge;void tarjan_init()&#123; init(); clr(dfn,0); bridge=idx=0; clr(isbridge,0); clr(fa,0);&#125;void tarjan(int u,int pre,int id)&#123; fa[u]=pre; low[u]=dfn[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; //...... if(!dfn[v])&#123; tarjan(v,u,i); low[u]=min(low[u],low[v]); if(low[v] &gt; dfn[u]) &#123; isbridge[v]=1,bridge++; //cout&lt;&lt;"isbridge"&lt;&lt;endl; &#125; &#125; else if(v!=pre)&#123; //。。。。。 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125;//注意isbridge数组与fa数组一起用，且若isbridge[i]，则i和fa[i]是割边//重边要不要注意写法 割边割点注意=号]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>连通性</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论前向星板子]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%9B%BE%E8%AE%BA%E5%89%8D%E5%90%91%E6%98%9F%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top]=Edge&#123;c,b,head[a]&#125;; head[a]=top++;&#125;void init()&#123; top=0; memset(head,-1,sizeof(head));&#125;//遍历方式for(int i=head[u];~i;i=edge[i].next)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束入门+总结]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%85%A5%E9%97%A8-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[差分约束入门+总结 给定一串序列，长度为n。$a_1,a_2,a_3……a_n$并给定m的限制条件，条件的格式为$a_i-a_j&lt;=c$求$a_n-a_1$的最大值考虑序列三个数a，b，c$a-b&lt;=v_1$$b-c&lt;=v_2$$a-c&lt;=v_3$$\Longrightarrow a-c&lt;=min(v_3,(v_1+v_2))$这个缩小约束条件的过程就是求最短路的过程所以可以用最短路模型来解决 模型1.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&lt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最大可能差值？方法：对于每个限制条件$a_i - a_j&lt;=c$，从点j到点i建立一条边(c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。 推广 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？就是反一反$a-b&gt;=v_1$$b-c&gt;=v_2$$a-c&gt;=v_3$$\Longrightarrow a-c&gt;=max(v_3,(v_1+v_2))$要满足所有条件，（a-c的）范围扩大，求最长路 模型2.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_i - a_j&gt;=c$，从点j到点i建立一条边(c)，求$a_{k2}$ 到 $a_{k1}$ 的最长路即可。 条件转换：$a-b&lt;=c \Longrightarrow b-a&gt;=c$$a-b=c \Longrightarrow a-b&lt;=c , b-a&lt;=c$….(简单数学变换) 模型2也可转换为模型1$a-b&gt;=v_1$ ``_````$b-a&lt;=-v_1$$b-c&gt;=v_2 \Longrightarrow$ $c-b&lt;=-v_2$$a-c&gt;=v_3$ ```````$c-a&lt;=-v_3$求$a_{k2}$ 到 $a_{k1}$ 的最短路模型2优化.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_j - a_i&lt;=-c$，从点i到点j建立一条边(-c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。 对于一个求最短路（最长路）约束条件有可能有三种情况：1.有上界，即有解2.无解（有负环）3.任意多的解（约束条件不够强，或者说图不强连通） 有解就是最短路无解就是有负环，最短路负无穷大无穷解就是不连通，最短路正无穷大 题目集： 最长路（模板题）https://blog.csdn.net/wyxxzsy/article/details/82777158再提一句，超级源点，一开始对于网上加入超级源点，直接计算最短路很不理解，因为加入超级源点之后，源点到每个点的距离至多是0,所以我一度认为，加入超级源点只是为了图的连通性，判断负环而已。但在最长路模型里不一样，它的权值都是负的，正确的权值是-dis[v],0到反而是最小值（加负号后）了，不会影响答案，有意思。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1201（差分约束入门）]]></title>
    <url>%2F2018%2F09%2F19%2FPOJ-1201%EF%BC%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%85%A5%E9%97%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[返回专题https://blog.csdn.net/wyxxzsy/article/details/82776590废话不说，直接建模套板子x[i] 代表 0～i 里点的个数对于若干个x[i],有若干个约束条件如样例：53 7 38 10 36 8 11 3 110 11 1 第一个约束条件“3 7 3”就是x[7]-x[2]&gt;=3最终要求 x[最大]-x[最小-1]的最小值转换成最长路 模型2优化.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_i - a_j&gt;=c\Longrightarrow a_j - a_i&lt;=-c$，从点i到点j建立一条边(-c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。https://blog.csdn.net/wyxxzsy/article/details/82776590 除了明说的限制，还有隐含的条件$0&lt;= a_i-a_{i-1}&lt;=1$从i～（i-1）加-c的边 就ok了（被什么超级源点搞了半天，狗屎）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=50010;const int M=500010;int n,m;int dis[N];struct edge&#123; int to;int v;&#125;;vector&lt;edge&gt; G[N];int vis[N];int cnt[N];//每个点的入队次数void init()&#123; for(int i=0;i&lt;=N;i++) G[i].clear();&#125;void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int cost=G[u][i].v; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf("%d",&amp;m); int s=INF,e=0; init(); while(m--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); a++,b++; s=min(a,s); e=max(e,b); addedge(a-1,b,-c); &#125; for(int i=s;i&lt;=e;i++)&#123; addedge(i-1,i,0); addedge(i,i-1,1); &#125; n = e-s+10; spfa(s-1); printf("%d\n",-dis[e]); return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1821 Fence (dp+单调队列优化)]]></title>
    <url>%2F2018%2F09%2F04%2Fpoj-1821-Fence-dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[给n个篱笆，k个工人接着给k行，分别描述工人的 负责区域大小 涂一个篱笆的收益 他所站的位置解释一下，一个工人如果涂篱笆了，一定是从他所站的位置出发的，即他负责的区域必须包括自己当前位置求最大的总收益dp[i][j] : 前i个工人 负责前j个篱笆的的最大收益 dp[i][j]=max(dp[i][j-1], dp[i-1][j-1], max(dp[i-1][k]+cost[i]*(j-k)) ) 详细解释一下 dp[i-1][k]+cost[i]*(j-k)前i-1个人负责前k个，剩下（j-k）个篱笆全由第i个人负责。j-len&lt;=k&lt;=pos-1有两个条件：1.第i个人要能负责到第k+1个2.j要大于等于其pos 程序分成两个部分：维护优先队列的部分，计算答案的部分 优先队列里维护什么值维护 dp[i-1][j]-cost[i]*j 的最大值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;struct node&#123; int len,pos,cost; bool operator &lt;(const node&amp; a)const &#123; return pos&lt;a.pos; &#125;&#125;a[110];int dp[110][16050];int q[16050];int main()&#123; int n,k; while(~scanf("%d%d",&amp;n,&amp;k))&#123; for(int i=1;i&lt;=k;i++) scanf("%d%d%d",&amp;a[i].len,&amp;a[i].cost,&amp;a[i].pos); sort(a+1,a+k+1); clr(dp,0); for(int i=1;i&lt;=k;i++) &#123; int h=0,t=0; q[t++] = max(0,a[i].pos-a[i].len);//找起点 for(int j=1;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1]); if(j&gt;=a[i].pos+a[i].len) continue; while(h&lt;t &amp;&amp;q[h]+a[i].len &lt; j) h++;//不合法 if(j&lt;a[i].pos)&#123; int tmp=dp[i-1][j]-j*a[i].cost; while(h&lt;t &amp;&amp; dp[i-1][q[t-1]]-q[t-1]*a[i].cost &lt; tmp) t--; q[t++] = j; &#125; else&#123; dp[i][j] = max(dp[i][j],dp[i-1][q[h]]+a[i].cost*(j-q[h])); &#125;//这里不能入栈 k&lt;=pos-1 //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;dp[i][j]&lt;&lt;endl; //cout&lt;&lt;h&lt;&lt;" "&lt;&lt;t&lt;&lt;endl&lt;&lt;endl; &#125; &#125; printf("%d\n",dp[k][n]); &#125; return 0;&#125;/*8 43 2 23 2 33 3 51 1 7*/ *tip：取队列尾部元素的时候要减1]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3530 单调队列入门]]></title>
    <url>%2F2018%2F09%2F03%2FHDU-3530-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[伪入门 滑动窗口两个队列：|单调递减|维护最大值|||—||单调递增|维护最小值||假设目前在处理第i个元素的入队列情况，首先，这个元素肯定是要入队列的，只是直接放在队列尾部和替换掉尾部一些元素的区别。eg.|1|3|2|5|4|—| 两个队列的情况分别为|两个队列|1|3|2|5|4||———||维护最大值（递减序列）|1|3|3-2|5|5-4||维护最小值（递增序列）|1|1-3|1-2|1-2-5|1-2-4| 这个队列有什么用？以5为例子，|3-2|3是到5为止最大的值,2是抛弃掉3之后到5为止最大的值||-| 1-2 1是到5为止最小的值,2是抛弃掉1之后到5为止最小的值 所以不难理解他们的递减性和递增性 所以队列里面存的是什么？是最大值（最小值） 更详细地来说，队列头存放着可行范围的最大值，接着是 范围离开了队列头的位置后 产生的新最大值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int N=1e5+10;int q_max[N],q_min[N];//max维护最大值 递减int a[N];int n,m,k;//m&lt;= val &lt;=kint main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; int tmp=0,ans=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int h1=0,t1=0,h2=0,t2=0; for(int i=1;i&lt;=n;i++)&#123; //真正的值是尾部-1 while(h1&lt;t1 &amp;&amp; a[q_max[t1-1]] &lt; a[i]) //相同值留在里面 t1--; while(h2&lt;t2 &amp;&amp; a[q_min[t2-1]] &gt; a[i]) t2--; q_max[t1++]=q_min[t2++]=i; //找到要抛弃的最值（最大或最小值，因为改变一个就改变了他们的差值） //也可能不抛弃任何一个，tmp值不变。 while(h1&lt;t1&amp;&amp;h2&lt;t2 &amp;&amp; a[q_max[h1]]-a[q_min[h2]]&gt;k) //找哪个最值在前面,决定不要哪个 if(q_max[h1]&lt;q_min[h2]) tmp=q_max[h1++]; else tmp=q_min[h2++]; if(h1&lt;t1&amp;&amp;h2&lt;t2 &amp;&amp; a[q_max[h1]]-a[q_min[h2]] &gt;= m) ans=max(ans,i-tmp); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1693 插头dp]]></title>
    <url>%2F2018%2F09%2F02%2FHDU-1693-%E6%8F%92%E5%A4%B4dp%2F</url>
    <content type="text"><![CDATA[什么是插头dp？首先我们要先知道它能解决那些问题。一般都是一张方格图里有关连通性的一些问题。那么对于一个格子而言，他就可能会有一些线经过它。（所以也可以没有，看题目）例如这张图那么插头就是描述这些线条如何穿过这些格子 那如何用插头来表示一种状态？对于一个宽度为m的图，它的插头就有m+1种，每一种插头的01状态代表这个位置有没有插头。 那么状态如何转移呢？就这么几种状态，可以分类讨论或者适当简化一下。 一行之尾与下一行之首间的转化 初始化的时候就是-1行state为0时才为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;int G[15][15];LL dp[2][(1&lt;&lt;12)+10];int n,m;int main()&#123; int t;scanf("%d",&amp;t); int cas=0; while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;G[i][j]); int total=1&lt;&lt;(m+1); //初始化 clr(dp,0); //至于其他初值取决于行之间的转移 dp[1][0]=1; int cur=1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123;//对 int plug1=(1&lt;&lt;j),plug2=(1&lt;&lt;(j+1)); cur^=1; clr(dp[cur],0); for(int st=0; st&lt;total; st++)&#123; if(G[i][j])&#123; dp[cur][st^plug1^plug2] += dp[cur^1][st]; if(((plug1&amp;st)==0)^((plug2&amp;st)==0)) dp[cur][st]+=dp[cur^1][st]; &#125; else &#123; if((plug1&amp;st)||(plug2&amp;st)) dp[cur][st]=0; else dp[cur][st] += dp[cur^1][st]; &#125; &#125; &#125; cur^=1; clr(dp[cur],0); for(int st=0;st&lt;(1&lt;&lt;m);st++) dp[cur][(st&lt;&lt;1)] += dp[cur^1][st]; &#125; printf("Case %d: There are %lld ways to eat the trees.\n",++cas,dp[cur][0]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>插头dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮廓线dp入门题 && POJ - 2411]]></title>
    <url>%2F2018%2F08%2F29%2F%E8%BD%AE%E5%BB%93%E7%BA%BFdp%E5%85%A5%E9%97%A8%E9%A2%98-POJ-2411%2F</url>
    <content type="text"><![CDATA[题目很有意思，就是oj太烂了刘汝佳的代码太优雅了，看不懂，但意思差不多。就我做过的状压dp总是以一行（或一列）为一个状态，先理清一行中的关系，后再找行对行的关系这里不能用行，行之间的关系不够了，因为要考虑不同的放法。那一行不够，两行够不够？我觉得够，但时间复杂度不够优秀，会包含很多无效转态所以优化一下？ dp三个问题：1.状态的确立2.状态转移方程3.初始化 1.dp[i][j][state] : 右下角位置是（i，j），状态是state的总数因为只要求dp[n-1][m-1][$2^m-1$]的值滚动数组 为 dp[2][state]当前状态只于之前有关2.转移方程:若dp[cur][state]合理，那么转移到另一个合理状态。如何转移1.（上）考虑当前放竖着的块。前提:上方的状态为0（没放）并且 现在不是第一行dp[cur][可以到的状态]+=dp[1^cur][state]2.（不放）考虑当前没有以（i，j）为右下角的块前提:上方是1，（上方不能为0吧）dp[cur][可以到的状态]+=dp[1^cur][state]3.（左）。。。。差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define clr(a, x) memset(a, x, sizeof(a))typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF=0x3f3f3f3f;int n,m,cur;const int N =15;LL dp[2][1&lt;&lt;N];int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n+m))&#123; if(n&lt;m) swap(n,m); clr(dp,0); cur=0; dp[0][(1&lt;&lt;m)-1]=1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cur^=1; clr(dp[cur],0); for(int s=0;s&lt;(1&lt;&lt;m);s++)&#123; if(dp[1-cur][s]==0) continue; //上方 if(i!=0 &amp;&amp; (s&amp;(1&lt;&lt;(m-1)))==0) //非首行且上方是0 现在可以放竖着的块 &#123; int now = ((s&lt;&lt;1)|1) &amp; ((1&lt;&lt;m)-1); dp[cur][now] += dp[1-cur][s]; &#125; //左方 if( j!=0 &amp;&amp; (s &amp;(1&lt;&lt;(m-1))) &amp;&amp; (s&amp;1)==0 ) &#123; int now=((s&lt;&lt;1)|3)&amp;((1&lt;&lt;m)-1); dp[cur][now]+=dp[1-cur][s]; &#125; //不放 if(s &amp;(1&lt;&lt;(m-1)))&#123; int now=((s&lt;&lt;1)&amp;((1&lt;&lt;m)-1)); dp[cur][now]+=dp[1-cur][s]; &#125; &#125; &#125; printf("%lld\n",dp[cur][(1&lt;&lt;m)-1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>轮廓线dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 4539]]></title>
    <url>%2F2018%2F08%2F23%2FHDU-4539%2F</url>
    <content type="text"><![CDATA[纯状压题，dp部分很简单考虑一行上的限制条件，再去深究列上的限制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int state[1&lt;&lt;10];int soldier[1&lt;&lt;10];int G[110];LL dp[110][180][180];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; clr(G,0); clr(dp,0); clr(soldier,0); clr(state,0); for(int i=0;i&lt;n;i++) for(int j=0,x;j&lt;m;j++) &#123; cin&gt;&gt;x; if(!x) G[i]|=1&lt;&lt;j; &#125; int num=0; for(int i=0;i&lt;(1&lt;&lt;m);i++) &#123; if(i &amp; (i&lt;&lt;2)) continue; for(int j=0;j&lt;m;j++) if(i &amp; (1&lt;&lt;j)) soldier[num]++; state[num++] = i; &#125; LL ans=0; for(int i=0;i&lt;num;i++) &#123; if(G[0]&amp;state[i]) continue; dp[0][i][0] = soldier[i]; ans=max(ans,1LL*soldier[i]); &#125; if(n==1)&#123; cout&lt;&lt;ans&lt;&lt;endl; continue; &#125; for(int i=0;i&lt;num;i++) &#123; if(G[1]&amp;state[i]) continue; for(int j=0;j&lt;num;j++) &#123; if(G[0]&amp;state[j]) continue; if((state[j]&lt;&lt;1)&amp;state[i]) continue; if((state[i]&lt;&lt;1)&amp;state[j]) continue; dp[1][i][j] = max(dp[1][i][j],dp[0][j][0]+soldier[i]); ans=max(ans,dp[1][i][j]); &#125; &#125; for(int r=2;r&lt;n;r++) &#123; for(int i=0;i&lt;num;i++) &#123; if(state[i]&amp;G[r]) continue; for(int j=0;j&lt;num;j++) &#123; if(G[r-1]&amp;state[j]) continue; if((state[j]&lt;&lt;1)&amp;state[i]) continue; if((state[i]&lt;&lt;1)&amp;state[j]) continue; for(int k=0;k&lt;num;k++) &#123; if(G[r-2]&amp;state[k]) continue; if(state[k]&amp;state[i]) continue; if((state[k]&lt;&lt;1)&amp;state[j]) continue; if((state[k])&amp;(state[j]&lt;&lt;1)) continue; dp[r][i][j] = max(dp[r][i][j],dp[r-1][j][k]+soldier[i]); ans=max(ans,dp[r][i][j]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 11D]]></title>
    <url>%2F2018%2F08%2F23%2FCodeForces-11D%2F</url>
    <content type="text"><![CDATA[有意思 和之前的项链异曲同工，但之前就是入门，半抄半做的。one more time 再跑一遍吧环？怎么处理环？都是通过记录路径，若是首末可相连，那么就是个环，同时，这样也可以用作之后的状态转移，妙啊dp[i][s]: 路径的最后一个点是i且状态是s，且有隐含条件开头是是状态的第一个1。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define legal(a,b) a&amp;btypedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int G[21][21];LL dp[21][1&lt;&lt;20];//dp[i][state] 以第一个1出现的位置作为开头，以i结尾的路径的数量int num[1&lt;&lt;21];int n,m;//dp[i][s|(1&lt;&lt;i)] += dp[e][s]int solve(int state)&#123; int ans=0; for(int i=0; i&lt;=20; i++) if(state &amp;(1&lt;&lt;i)) ans++; return ans;&#125;int main()&#123; for(int i=0; i&lt;(1&lt;&lt;21); i++) num[i] = solve(i); while(cin&gt;&gt;n&gt;&gt;m) &#123; clr(G,0); for(int i=0,x,y; i&lt;m; i++) &#123; cin&gt;&gt;x&gt;&gt;y; x--; y--; G[x][y]=G[y][x]=1; &#125; clr(dp,0); //初始化 for(int i=0; i&lt;n; i++) dp[i][1&lt;&lt;i] = 1; int total=1&lt;&lt;n; LL ans=0; for(int s=1; s&lt;total; s++) &#123; //找开头 int st=0; for(int i=0; i&lt;n; i++) if(s&amp;(1&lt;&lt;i)) st=i,i=n; for(int i=st; i&lt;n; i++) //枚举状态中的结尾 if(s&amp;(1&lt;&lt;i)&amp;&amp;(dp[i][s])) for(int j=st; j&lt;n; j++) //枚举新状态的结尾 &#123; if(s&amp;(1&lt;&lt;j)) continue; if(G[i][j]==0) continue; dp[j][s|(1&lt;&lt;j)] += dp[i][s]; if(G[st][j] &amp;&amp; num[s|(1&lt;&lt;j)]&gt;=3) ans+=dp[i][s]; &#125; &#125; cout&lt;&lt;ans/2&lt;&lt;endl; &#125; return 0;&#125;/*4 61 21 31 42 32 43 4*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1565]]></title>
    <url>%2F2018%2F08%2F23%2FHDU-1565%2F</url>
    <content type="text"><![CDATA[这道题以为是简单的模板题（确实简单啊。。。），卡了好久1.内存限制，之前题放的很开，这里要卡一下最多的状态数，但没卡滚动数组（也卡不了吧）2.注意要统计的是最值还是数量。3.二进制状态 $2^n 和2^{n+1}$ 是分开的 可以预处理$2^{20}$ 再对不同n取前缀，但效果不明显。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;LL G[30][30];LL state[20000];LL sum[20][20000];LL dp[20][20000];int n;LL dfs(int r,int id)&#123; if(sum[r][id]) return sum[r][id]; int ans=0; for(int i=0;i&lt;n;i++) &#123; if(state[id]&amp;(1&lt;&lt;i)) ans+=G[r][i]; &#125; return ans;&#125;int main()&#123; int num=0; for(int i=0;i&lt;(1&lt;&lt;20);i++) if(!(i&amp;(i&lt;&lt;1))) state[num++] = i; while(cin&gt;&gt;n)&#123; clr(sum,0); clr(dp,0); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;G[i][j]); int total=(1&lt;&lt;n); int id=0; for(;id&lt;num;id++) if(state[id]&gt;total) break; LL ans=0; for(int i=0;i&lt;id;i++) &#123; dp[0][i] = dfs(0,i); ans=max(ans,dp[0][i]); &#125; for(int r=0;r&lt;n-1;r++) for(int i=0;i&lt;id;i++) if(dp[r][i]) for(int j=0;j&lt;id;j++) &#123; if(state[i]&amp;state[j]) continue; dp[r+1][j] = max(dp[r][i] + dfs(r+1,j),dp[r+1][j]); ans=max(ans,dp[r+1][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 发现一个轮廓线dp做法 有意思初始值（初始值的选取也有讲究）|0|0|0|0|0||-|-| 需要更新的值|x|x|0|1|0||-||1|0|?|x|x|状态$n^2-1$就是形似上图所示的意义。对于一个$n×n$的矩阵，从行，列一一遍历，同时更新每个可到达的状态的最大值。其他和入门题一致，比较简单。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define clr(a, x) memset(a, x, sizeof(a))typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF=0x3f3f3f3f;int n,cur;LL G[25][25];LL dp[2][1&lt;&lt;20];int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%lld",&amp;G[i][j]); clr(dp,0); cur=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) &#123; cur=1^cur; clr(dp[cur],0); for(int st=0;st&lt;(1&lt;&lt;n);st++)&#123; //取 if( (j==0||(st&amp;1)==0) &amp;&amp; (st&amp;(1&lt;&lt;(n-1)))==0) //已经保证首位不是1 dp[cur][(st&lt;&lt;1)|1] = max(dp[cur][(st&lt;&lt;1)|1],dp[1^cur][st]+G[i][j]); //不取 dp[cur][(st&lt;&lt;1)&amp;(1&lt;&lt;n)-1] = max(dp[cur][(st&lt;&lt;1)&amp;(1&lt;&lt;n)-1],dp[1^cur][st]); &#125; &#125; LL ans=0; for(int i=0;i&lt;(1&lt;&lt;n);i++) ans=max(ans,dp[cur][i]); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3091]]></title>
    <url>%2F2018%2F08%2F21%2FHDU-3091%2F</url>
    <content type="text"><![CDATA[有一个DP题，意题都看了好久用n个珠子串成一个项链，但是n个珠子两两之间可能不能放在一起，问有几种串珠子的方式？因为项链可以旋转，所以选择一个起点最终走到这个起点，且每个点只能走一次，问有多少种情况？ 类似旅行商问题，但不一样。问题还是对于一个珠子之后，它要选哪个珠子，因为n个珠子都要被选到，这里解决的就是个顺序问题。如何定义dp状态dp[state][i] :在state状态下，且以i为最后一个放入的元素的情况下的总数。 转移方式：从这个状态可以转移到的状态，目标状态总数+=现在的状态总数(状态之间只有加法的时候，这种转移很有用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int n,m;int G[20][20];LL dp[20][1&lt;&lt;19];//dp[i][j] 最后放的是i，状态为j的个数int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; clr(G,0); clr(dp,0); for(int i=0,x,y;i&lt;m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; x--;y--; G[x][y]=G[y][x]=1; &#125; dp[0][1] = 1;//固定一开始放0 那转态就是1 for(int st=1;st&lt;(1&lt;&lt;n);st++) //枚举状态 for(int j=0;j&lt;n;j++)//拆解转态 &#123; if(dp[j][st]==0) continue; for(int k=1;k&lt;n;k++) //0已经加进去了 无需考虑 &#123; if( G[j][k] &amp;&amp; (st&amp;(1&lt;&lt;k))==0 ) dp[k][st|(1&lt;&lt;k)]+=dp[j][st]; &#125; &#125; LL sum=0; for(int i=0;i&lt;n;i++)&#123; //cout&lt;&lt;dp[i][(1&lt;&lt;n)-1]&lt;&lt;endl; if(G[i][0])&#123; sum+=dp[i][(1&lt;&lt;n)-1]; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;/*3 31 21 32 3*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3182]]></title>
    <url>%2F2018%2F08%2F21%2FHDU-3182%2F</url>
    <content type="text"><![CDATA[一眼看上去有点像变形背包，但完全不是每种汉堡只能选一种，选一种，且选i种汉堡 需要先作出规定的汉堡比较难的就是如何判断这个状态是合法的，而对于确定的状态，答案是唯一的合法表现在两方面：1.val&gt;0 2.所有的汉堡满足依赖这里的处理很优美:从一个合法状态到另一个合法状态，打标记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int v[20],w[20];LL dp[(1&lt;&lt;16)]; //存放这种状态的最大收入LL en[1&lt;&lt;16];//........剩下的engint vis[1&lt;&lt;16];vector&lt;int&gt; sta[20];bool judge(int state,int add) //能不能把add加到这个状态下&#123; for(auto v:sta[add])&#123; if(!(state &amp; (1&lt;&lt;(v-1)))) return 0; &#125; return 1;&#125;int main()&#123; int t;cin&gt;&gt;t; while(t--)&#123; int n,E;cin&gt;&gt;n&gt;&gt;E; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i],sta[i].clear(); for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i]; for(int i=0;i&lt;n;i++)&#123; int num;cin&gt;&gt;num; while(num--)&#123; int x;cin&gt;&gt;x; sta[i].pb(x); &#125; &#125; clr(dp,0); clr(vis,0); en[0] = E; vis[0]=1; LL ans=0; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; if(vis[i]) for(int j=0;j&lt;n;j++) if(!(i&amp;(1&lt;&lt;j)) &amp;&amp; judge(i,j))&#123; if(en[i]-w[j] &lt; 0) continue; int now=i|(1&lt;&lt;j); dp[now] = dp[i]+v[j]; ans=max(ans,dp[now]); en[now] = en[i]-w[j]; vis[now]=1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1074]]></title>
    <url>%2F2018%2F08%2F21%2FHDU-1074%2F</url>
    <content type="text"><![CDATA[A - Doing Homework HDU - 1074入门题 很有意思最多十五门课 15位二进制0代表没选这门课 1代表选了这门课状态从 $ 0 $ ~$ (2^{n-1}) $即什么都没选到所有课对于一个state 我要知道这个状态时的罚时，就是从前一个能到达的转态中取使其罚时最小的状态转移过来，同时更新总时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int N=70000;string name[20];int deadline[20],length[20];int dp[1&lt;&lt;17]; //取这个状态要减多少分int t[1&lt;&lt;17];//到达这个转态的时间int pre[1&lt;&lt;17];void print_ans(int state)&#123; int j = pre[state]; if(state==0) return ; print_ans(state ^ (1&lt;&lt;j)); cout&lt;&lt;name[j]&lt;&lt;endl;&#125;int main()&#123; int cas;scanf("%d",&amp;cas); while(cas--)&#123; int n;scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) cin&gt;&gt;name[i]&gt;&gt;deadline[i]&gt;&gt;length[i]; for(int i=1;i&lt;(1&lt;&lt;n);i++) &#123; //对于状态i计算 dp[i] = INF; for(int j=n-1;j&gt;=0;j--) &#123; if(i&amp;(1&lt;&lt;j)) &#123; int now=i^(1&lt;&lt;j); //从now转移到i int reduce= t[now] + length[j] - deadline[j]; if(reduce&lt;0) reduce=0; if(dp[i] &gt; dp[now]+reduce)&#123; t[i] = t[now]+length[j]; dp[i] = dp[now]+reduce; pre[i] = j; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl; print_ans((1&lt;&lt;n)-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 6435]]></title>
    <url>%2F2018%2F08%2F21%2FHDU-6435%2F</url>
    <content type="text"><![CDATA[可惜了 这道题还是能做的首先这道题非常容易想到暴力做，但绝对不能暴力做，这一类的题型，我感觉要挖掘题面中的特有信息。比如: k&lt;=5,曼哈顿距离（去绝对值）当然都注意到了也没用，题做的少啊这一手状压还是很妙的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int N=1e5+10;const int INF=0x3f3f3f3f;LL a[1&lt;&lt;5];LL b[1&lt;&lt;5];LL state[10];int n,m,k;inline LL solve(int sta)&#123; LL ans=0; for(int i=0;i&lt;k;i++) if((1&lt;&lt;i)&amp;sta) ans+=state[i]; else ans-=state[i]; return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; clr(a,-INF); clr(b,-INF); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int total=1&lt;&lt;(k); for(int i=0,s;i&lt;n;i++) &#123; scanf("%d",&amp;s); for(int j=0;j&lt;k;j++) scanf("%lld",&amp;state[j]); for(int j=0;j&lt;total;j++)&#123; a[j] = max(a[j],s+solve(j)); //cout&lt;&lt;a[i][j]&lt;&lt;endl; &#125; &#125; for(int i=0,s;i&lt;m;i++) &#123; scanf("%d",&amp;s); for(int j=0;j&lt;k;j++) scanf("%lld",&amp;state[j]); for(int j=0;j&lt;total;j++) b[j] = max(b[j],s+solve(j)); &#125; //for(int i=0;i&lt;total;i++) cout&lt;&lt;b[i]&lt;&lt;endl; LL ans=0; for(int j=0;j&lt;total;j++)&#123; ans=max(ans,a[j]+b[total-j-1]); //cout&lt;&lt;j&lt;&lt;" "&lt;&lt;total-j-1&lt;&lt;endl; &#125;// cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp专题总结]]></title>
    <url>%2F2018%2F08%2F19%2Fdp%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[dp专题总结 所有的dp关键有两点1.看出来这是一道dp题 （看时间复杂度）2.状态转移方程！！！！其中状态的确立和推出状态转移方程是个难点,而且dp题还经常会和其他知识点融合在一起搞你，非常灵活。先从有迹可循的一些经典dp问题入手 一.数位dp1.确立状态如何确立一个正确的dp数组？dp[pos][state1][state2][….]首先第一维代表着数位若是人为规定的话： 0-个位 1-十位 2-百位 3……那么后面的state代表的就是 所有的的i位数满足的性质eg. 如果要记录所有四的倍数的数量 （当然有更简单的容斥做法，这里只是举个例子）开 dp[pos][mod]那么dp[3][2]代表着所有千位数（0000-9999）中%4余2的个数 那怎么确定我们要开那些状态？1.题目中明确要求的2.影响状态转移的（前导0什么的）例如 http://acmoj.shu.edu.cn/problem/65/每组数据只有一行，包含三个整数 L_i,R_i,m。在 [L_i,R_i ] 区间，有多少个数奇偶和等于 m，以及这些数的和（对和取模100000007后输出）。 和 http://hihocoder.com/problemset/problem/1033描述给定一个数 x，设它十进制展从高位到低位上的数位依次是 a0, a1, …, an - 1，定义交错和函数：f(x) = a0 - a1 + a2 - … + ( - 1)n - 1an - 1例如：f(3214567) = 3 - 2 + 1 - 4 + 5 - 6 + 7 = 4给定 l, r, k，求在 [l, r] 区间中，所有 f(x) = k 的 x 的和，即： 这两道题非常像，但是不同的地方导致我们的状态方程也不一样。先考虑第一道题:对于pos位,我们想要得到答案dp[pos][sum] 只需从dp[pos-1][sum-sgn*i]转移而来，用代码来表示的话，就是：12345678910for(int i=0; i&lt;=up; i++) &#123; int val; if(i&amp;1) val=i*(-1); else val=i; node tmp=dfs ( pos-1, m - val, limit &amp;&amp; i == up); ans.num += tmp.num; ans.sum=(ans.sum+i*POW[pos]%mod*tmp.num%mod +tmp.sum)%mod; &#125; dp[pos][sum]:pos位数中满足奇偶和是sum的个数与其总和我们只需开多开一维sum记录 pos位数中满足奇偶和是sum的个数当前的加减与当前的i有关，与之前和之后的数无关，转移并不会冲突。 第二道题：我们能否也和上一题一样也开 dp[pos][sum]呢？那好，先来解释一下 如果只开两维 dp数组的意义：pos位数满足交错和为sum时的个数和总和乍一看没问题，但当你写状态转移的时候，就会发现状态该怎么转移？状态没法转移，当前是加，那么下一位就是减，反之亦然。你没有办法区分当前是正是负 还是前导0，当前状态的不同会导致之后状态也不一样。所以给每个数再加上个性质：当前位的符号dp[pos][sum][sgn]sgn: 0-有前导0 ,1-正, -1 负 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct node&#123; LL num,sum;&#125;dp[30][500][3]; //偏移量240//第三维代表leadint a[30];LL Pow[30];int k;//lead 0-有前导0 1-正 -1 负node dfs(int pos,bool limit,int lead,int sum)&#123; if(pos==-1)&#123; return node&#123;sum==0,0&#125;; &#125; if(!limit&amp;&amp; dp[pos][sum+240][lead].num!=-1) return dp[pos][sum+240][lead]; node ans=node&#123;0,0&#125;; int up=limit?a[pos]:9; for(int i=0;i&lt;=up;i++) &#123; //处理前导0 int sgn=1; if (lead==0 &amp;&amp; i==0) sgn=0; else if(lead==0 &amp;&amp; i!=0) sgn=1; else sgn=-lead; node tmp=dfs(pos-1,limit&amp;&amp;i==up,sgn,sum-sgn*i); LL num=tmp.num,sum=tmp.sum; (ans.num+=tmp.num)%=mod; ans.sum+=Pow[pos]*i %mod *num %mod+ sum; ans.sum%=mod; &#125; return limit?ans:dp[pos][sum+240][lead]=ans;&#125;LL solve(LL x)&#123; if(x==-1) return 0; int pos=0; while(x)&#123; a[pos++] = x%10; x/=10; &#125; return dfs(pos-1,1,0,k).sum;&#125; 其他难以确立的状态还有很多，比如大都会的四维dp，比如各种模数，连续字串。但最为关键的就是记住dp[pos][state1][state2][…]每多一个状态，那么就是pos位的数进一步被细分，可以看做是各种性质的交集，怎么去分这个数，就是确立状态的关键。 2.状态的转移其实状态的转移多多少少要在确立这个状态的时候一并考虑到了，毕竟状态要能正确的转移，我们才能说这个确立的状态是对的嘛。而数位dp的转移是比较单纯的，因为多半就是从高位到地位枚举，从低位到高位转移，而我们一般都是用数位dp记录满足条件数的个数，转移比较简单，写出dp数组，一般转移就出来了。那如果要记录所有满足条件数的总和，平方和，别的什么奇奇怪怪的东西呢？额，目前就遇到过 和 与 平方和。和：当前枚举的数×当前的位权×（要转移到的）低位的满足某性质的个数+（要转移到的）低位的满足某性质的个数eg：$ \cdots x \cdots $令$x_1~x_n$都是满足条件的低一位的数$ sum = （x+x_1）+(x+x_2)+ \cdots (x+x_n) =n*x + x_1+\cdots+x_n$开个struct 记录num和sum 平方和： $ ans = (x+x_1)^2 + (x+x_2)^2 + \cdots + (x+x_n)^2 $ &emsp;&emsp; $ =n*x^2+2x(x_1+x_2+ \cdots +x_n)$ 所以要维护三个值：个数 总和 平方和 eg https://vjudge.net/contest/70324#problem/J 二概率dp（期望dp）感觉都可以用数学简化，但数学功底不够，就用dp来凑]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 多校赛一]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%89%9B%E5%AE%A2-%E5%A4%9A%E6%A0%A1%E8%B5%9B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ALGV算法 抄一波 牛客的解释 （wiki 没耐心看了）作者：zzuzxy链接：https://www.nowcoder.com/discuss/87452?type=101&amp;order=0&amp;pos=1&amp;page=1LGV 算法 (Lindström–Gessel–Viennot lemma)求以上矩阵的行列式，其中 e(a,b) 是从a到b的方法数，带入求行列式即可得到(a1,a2,…an) 到 (b1,b2,…bn) 的所有不相交路径的种数再看这道题，其实就是要找从(n,0)到（0,m）的两条可重合的路径。如何将模型转移到不相交？一条路往左下角移一格a1,a2 ——- (n,0) (n-1,-1)b1,b2——— (0,m) (-1,m-1)e(a1,b1) = ….……ans= B Symmetric Matrix很有意思，从矩阵—关联到邻接矩阵（图论）—dp最终转换得到的题意是：给你n个不同的点，问能组成多少不同的环先考虑n个不同的球能组成多少不同的一个环 即：环排列 （n-1）!dp我是想不到的，那就走一遍吧：dp[n] 为数量为n的情况下，有多少的环的情况1.从n-1个点里找出1个点 与新加的点组成一个环(n-1)dp[n-2]2.从n-1个点中找出k个点 ，与新加的那个点组成一个环C(n-1,k) dp[n-k-1](k-1)!……………………………….死活推不出。。。这一数学题。老姐推出的。不贴代码了 就照着公式写f(n) = (n-1) f(n-2) +sum{k从2-(n-2)} ((n-1)!*f(k)/k!/2) E 大意：对于一个长度为 n 的由（1-k）组成的序列，去掉m个字符的不同子序列有多少个？ 由去掉m个字符组成子序列可以理解为只取（n-m）个字符组成的不同序列。首先遇到的问题是什么？同一个字符串可以有多种取法，那么如何筛除重复，就是这个问题的关键。1官方题解写的很不错。用dp做dp[i][j] 代表取第i个位置的数，且其中删除了j个数的情况数再去计算next[i][c] 代表第i个位置之后 第一个为c的位置（不包括位置i，且若是没有，统一为n+1）那么这样一来状态转移方程就是什么啊？dp[next[i][c]] [ next[i][c]-i-1+j ] +=dp[i][j]解释一下（我自己都看了好久。。。人蠢就要多努力）对于一串原序列与子序列：例如 原 1 2 1 2 1 1 2 1 子 1 1 2 （dp[4][1] ——-删了位置2） 对于 子序列 1 1 2 它下一个的取值有4种情况 恰好是pos 5~8，但是若是m=1（只删除一个）的话，pos 5，6，8就会多次记录，所以不能从位置四一一转移到 5 6 8，只能留一个，留哪个？很显然，留5，它是第一个出现的“1”，它的末尾可以接更多的值，就像直播时的前辈说的那样，这个有点贪心的感觉。如何去重的呢？看例子的位置 5 dp[5][0]=2 (11和21）怎么得到的11和21呢？位置是35和45只考虑这个数之前的第一个值。2之后看牛客别人的代码，发现大多数人不是这样做的，他们是如何处理的呢？dp[i][j]代表前i个位置，删j 个数的情况数（注意，这里不强制要求第i个数必须取，所以答案直接就是dp[n][m]）转移方程：dp( i , j ) = dp( i-1, j) +dp ( i-1, j-1) //第i个数不取+第i个数取显然，这里会有重复，我很好奇，他们是怎么处理重复的？if(pre[i]&amp;&amp;pre[i]+j-i&gt;=0) dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;额？这波操作有点秀啊，看不懂啊！！不过怎么这么熟悉呢if(pre[i]&amp;&amp;i-pre[i]&lt;=j)//如果位置i的前一个位置的数存在，并且能删那么多数 dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;举例子：1 2 3 4 3 3 2 1到pos 5 就有问题了 序列123 13 23就会有重复了假设在pos5前dp[i][j] 一直保持它原本的意义 那么根据转移式dp[5][0] 没重复，不用减dp[5][1]没重复，不用减dp[5][2]重复出现了 且减去 dp[2][1] （对应123）dp[5][3] 减去 dp[2][2] （对应12，13 ）dp[5][4]…….都减去一个0（因为dp越界了）好神奇啊 为什么啊？有什么神奇的，就是字面意思嘛首先要减去的这个dp值的位置肯定是pre[i]-1因为之后才确定是哪个3嘛那j是多少呢 pre[i]+j-i 即 j -（ i-pre[i] ）中间都不删啊,(有中间的元素的话，就是一个新序列了嘛)3还有一种做法ans[len] 代表长度为len的序列种数nxt[len][num]代表长度为len，之后数字为num的种数那么 ans[len] += ans[len]-1 - nxt[len][a[i]]dp[i][j] = ans[j-1]//额 看不懂了，贴一下代码之后消化吧1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define N 2000050using namespace std;typedef long long LL;const int MAX=1e5+10;long long dp[MAX][20];const int MOD= 1e9+7;long long ans[MAX];long long a[MAX];int main()&#123; int n,m,k; while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;k))&#123; for(int i=1;i&lt;=n;i++)&#123; ans[i]=0; memset(dp[i],0,sizeof dp[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; ans[0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&gt;=1 &amp;&amp; j&gt;=i-m-1;j--)&#123; ans[j]=(ans[j]+ans[j-1]-dp[j][a[i]])%MOD; dp[j][a[i]]=ans[j-1]; &#125; &#125; ans[n-m]=(ans[n-m]+MOD)%MOD; cout&lt;&lt;ans[n-m]&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin专题 搜索]]></title>
    <url>%2F2018%2F07%2F18%2Fkuangbin%E4%B8%93%E9%A2%98-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[E醉了，说有100位的十进制数，我想那会炸的啊，没想到啊，所有的答案都在long long范围内，那时候应该打个表看看 Fbfs 水题 G模拟题 怎么就搜索了？？没做 Hbfs + 记录路径怎么记录路径？记录每个点的前驱，像并查集那样向上跳，就是所求的路径。但这里有一个问题，它要准确打印操作是什么（我猜）就两个解决方法1：记录下来 就结构体里多加点东西咯2：打印答案路径的时候，对比v与前驱pre[v]，判断是什么我这里用了第二种方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;typedef pair&lt;int, int&gt; PII;int vol1,vol2,n;map &lt;PII,int &gt; vis;map &lt;PII,PII&gt; pre;int num;void ok()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;void dfs(PII tmp)&#123; if(pre.find(tmp)!=pre.end()) &#123; num++; dfs(pre[tmp]); int u1=tmp.X,v1=tmp.Y; int u2=pre[tmp].X,v2=pre[tmp].Y; if(u1+v1==u2+v2)&#123; cout&lt;&lt;"POUR("; if(u1&gt;u2) cout&lt;&lt;"2,1"; else cout&lt;&lt;"1,2"; cout&lt;&lt;")"&lt;&lt;endl; &#125; else if(u1==vol1&amp;&amp;u2!=vol1) cout&lt;&lt;"FILL(1)"&lt;&lt;endl; else if(v1==vol2&amp;&amp;v2!=vol2) cout&lt;&lt;"FILL(2)"&lt;&lt;endl; else if(u1==0&amp;&amp;u2!=0) cout&lt;&lt;"DROP(1)"&lt;&lt;endl; else if(v1==0&amp;&amp;v2!=0) cout&lt;&lt;"DROP(2)"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;&#125;int main()&#123; while(cin&gt;&gt;vol1&gt;&gt;vol2&gt;&gt;n) &#123; vis.clear(); queue&lt;PII&gt; q; q.push(PII(0,0)); int finish=0; while(!q.empty()) &#123; PII tmp=q.front(); vis[tmp] = 1; q.pop(); int u=tmp.X,v=tmp.Y; if(u==n||v==n) &#123; num=0; dfs(tmp); finish=1; break; &#125; //三个操作 六种情况 int uu,vv; uu=vol1,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=vol2; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=0,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=0; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=min((u+v),vol1),vv=u+v-uu; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; vv=min((u+v),vol2),uu=u+v-vv; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; &#125; if(!finish) &#123;puts("impossible");continue;&#125; &#125; return 0;&#125; I - Fire Game FZU - 2150又一个神奇的oj 没c++11我写的好不习惯。不过这题还不错，让我折腾了好久。几个点：1.永远注意数据范围虽然数据小不意味着就要暴力，但这道题太tm小了，想用巧妙的方法做错了啊2.要用vis数组的话，push前就更新比较保险3.bfs别忘了pop，虽然总能debug出来，但好浪费时间啊，你就给我注意一下啊题本身倒没什么，暴力跑bfs就可以了，吐槽一下 n^6我tm写了四个循环，这怎么看都要t了，奈何不住数据小啊tips：看到一个优化在枚举的时候 第三重和第四重可以不用从0枚举12for(int ii=0;ii&lt;n;ii++) ==》 for(int ii=i;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) ==》 for(int jj=i==ii?j:0;jj&lt;m;jj++) 看大佬的代码 至于为什么。。。，容我三思 额，其实就是因为如果每行从自己开始的话会漏掉前面的一些点 或者干脆只优化一行，时间也没差多少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef unsigned long long LL;typedef pair&lt;int,int&gt; PII;const int INF = 0x3f3f3f3f;const double eps = 1e-6;int n,m;char G[20][20];int vis[20][20];int dis[20][20];int res;int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;inline bool check(int x,int y)&#123; return x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;G[x][y]=='#';&#125;void bfs(int x1,int y1,int x2,int y2)&#123; queue&lt;PII&gt; q; clr(vis,0); clr(dis,0); q.push(PII(x1,y1));vis[x1][y1]=1; q.push(PII(x2,y2));vis[x2][y2]=1; int ans=0; while(!q.empty())&#123; PII u=q.front(); q.pop(); ans=dis[u.X][u.Y]; for(int i=0;i&lt;4;i++)&#123; int xx=u.X+dx[i],yy=u.Y+dy[i]; if(check(xx,yy)&amp;&amp;!vis[xx][yy]) &#123; vis[xx][yy]=1; dis[xx][yy]=ans+1; q.push(PII(xx,yy)); &#125; &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#'&amp;&amp;!vis[i][j]) return ; res=min(res,ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int k=1;k&lt;=t;k++)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",G[i]); res=INF; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#') for(int ii=0;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) if(G[ii][jj]=='#') &#123; bfs(i,j,ii,jj); &#125; if(res==INF) res=-1; printf("Case %d: %d\n",k,res); &#125;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>搜索</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180717SHU暑期集训训练赛(6)===]]></title>
    <url>%2F2018%2F07%2F17%2F20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B-6%2F</url>
    <content type="text"><![CDATA[B D E K L是看过的题但没过 B蔡老师强啊 样例看了好久看不懂，磨到晚上蔡老师才指点迷津先解释样例1 2 有三组 就是3C2=3（1 2 ，3 1）和（3 1，1 2）为一组（1 2，1 2，3 1）和（1 2，3 1，1 2）为一组加起来五组 （这道题看似图论，跟图论没半毛钱关系）之前不小心看到题解了是hash，还是两次hash，怎么搞？想一想。想不出啊。让我猜猜看，边hash成一个值，多条边再hash成一个值？？不对啊 老哥额 还要一个公式 (n+1)C2 - nC2 = n就是说每加入一个新的值 ans都要加上 原有个数（注意不是n+1是n）相同值的hash值相加一样没问题，但不同的数的hash值相加会不会也一样？应该不一样把，人家都过了这道题了，hash不就是解决这个问题的嘛，不清楚，没学过。双hash函数 保证没有例外12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1&lt;&lt;12;//两个hash函数 所需seed 和 pLL seed1=13131313,seed2=23333333,mod1=1e9+7,mod2=1e9+9;LL p1[N],p2[N];map &lt;pair&lt;int,int&gt;,LL&gt; id;int a[N];map&lt;pair&lt;int,int&gt;,LL&gt; cnt[N];int main()&#123; p1[0]=p2[0]=1; for(int i=1; i&lt;N; i++) p1[i] = p1[i-1] * seed1 % mod1; for(int i=1; i&lt;N; i++) p2[i] = p2[i-1] * seed2 % mod2;//这两步的意义是处理什么？写hash函数 fastin int t; cin&gt;&gt;t; while(t--) &#123; id.clear(); int n; cin&gt;&gt;n; for(int i=0,x,y; i&lt;n; i++) &#123; //将边hash成一个id值 cin&gt;&gt;x&gt;&gt;y; if(x&gt;y) swap(x,y); if(id.find(&#123;x,y&#125;)==id.end()) id[&#123;x,y&#125;] = id.size(); a[i] = id[&#123;x,y&#125;] ; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) cnt[i].clear(); for(int i=0; i&lt;n; i++) &#123; LL sum1=0,sum2=0; for(int j=i; j&lt;n; j++) &#123; (sum1+= p1[a[j]]) %=mod1; (sum2+= p2[a[j]]) %=mod2; ans+=cnt[j-i][ &#123;sum1,sum2&#125;]; //厉害啊 想不到 cnt[j-i][ &#123;sum1,sum2&#125;]++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 半抄半做的题，到时候再重新做一下 D The main idea is that we only need to keep track of the number of active cells and the last strictly increasing sequence of powers from right to left, this is because if we have a cell with number X and the cell to the right has number Y where Y &gt; X , these two cells will never merge and therefore anything to the left of them won’t add anything to the score so we don’t need to keep track of them.This leads to a DP Bitmask solution where we store the bitmask of available powers of 2 (they are guaranteed to be strictly increasing from right to left because we ignore any powers that aren’t) and the number of active cells (free cells + number of bits in the mask).If the current mask is msk and a 4 is generated, the new mask will become msk + 4 and ((msk)^(msk + 4)) - 4 will be added to the score.When a 2 is generated, the new mask will become msk + 2 and ((msk)^(msk + 2)) - 2 will be added to the score.The added score explained above is the score added from all the merge operations that will happen after adding the new number, not only the first one. Merging them all at once will not affect the final answer.^ is the bitwise XOR operator. 毫无头绪，不好意思英文的题解，慢慢啃吧尽力了 下一道E。。。。下一道 K生成树 ，李老师说的对啊，我错了先找到环上的任意一条边，去掉它，这张图就成为一个树了那么不考虑去掉的那条边，就是一个lca问题。只是在这里没有那么简单，要考虑经过那条边的情况，无非多出两种情况总共三种情况 1.不经过u—-v lcm //不经过去掉的边2.从u到v w+x—u+y—v3.从v到u w+x—v+y—u 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1e5+10;struct edge&#123; int to; LL w;&#125;;vector&lt;edge&gt; G[N];int father[N];int Find(int x)&#123; return x==father[x] ? x : father[x]=Find(father[x]);&#125;void Union(int x,int y)&#123; int rx=Find(x),ry=Find(y); if(rx==ry) return ; father[rx]=ry;&#125;//lca 一dfs处理深度 和faint dep[N],fa[N][30];LL d[N];//i到1的距离int n,q;void dfs(int u,int pre,LL dis)&#123; fa[u][0]=pre; d[u] = dis; for(auto tmp:G[u]) &#123; int v=tmp.to; LL distance=tmp.w; if(v!=pre) &#123; dep[v]=dep[u]+1; dfs(v,u,d[u]+distance); &#125; &#125;&#125;void bz()&#123; for(int j=1; j&lt;=29; j++) for(int i=1; i&lt;=n; i++) fa[i][j] = fa[fa[i][j-1]][j-1];&#125;void LCAinit()&#123; clr(dep,0); dep[1]=1; clr(d,INF); dfs(1,0,0); bz();&#125;int LCA(int u,int v)&#123; if(dep[u]&gt;dep[v]) &#123; swap(u,v); &#125; int cha = dep[v] - dep[u]; int len = log2(n); for(int x=0; x&lt;=len; x++) if((1&lt;&lt;x)&amp;cha) v=fa[v][x]; if(u==v) return u; for(int x=len; x&gt;=0; x--) &#123; if(fa[v][x]!=fa[u][x]) &#123; u=fa[u][x]; v=fa[v][x]; &#125; &#125; return fa[u][0];&#125;LL dis(int x,int y)&#123; int c=LCA(x,y); return d[x]+d[y]-2*d[c];&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; for(int i=0;i&lt;=n;i++) G[i].clear(); scanf("%d%d",&amp;n,&amp;q); for(int i=0; i&lt;=n; i++) father[i]=i; int in,out,w; for(int i=0,x,y; i&lt;n; i++) &#123; LL val; scanf("%d%d%lld",&amp;x,&amp;y,&amp;val); if(Find(x)==Find(y)) &#123; in=x,out=y,w=val; &#125; else &#123; Union(x,y); G[x].push_back(edge&#123;y,val&#125;); G[y].push_back(edge&#123;x,val&#125;); &#125; &#125; LCAinit(); for(int i=0,x,y; i&lt;q; i++) &#123; scanf("%d%d",&amp;x,&amp;y); LL ans=dis(x,y); ans=min(ans,dis(x,in)+dis(out,y)+w); ans=min(ans,dis(x,out)+dis(in,y)+w); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716SHU暑期集训组队赛(5)===]]></title>
    <url>%2F2018%2F07%2F16%2F20180717SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E7%BB%84%E9%98%9F%E8%B5%9B-5%2F</url>
    <content type="text"><![CDATA[又tm垫底了两道图论+二分答案没过模板 迪杰斯特拉最短路 + 二分答案 二分图匹配+二分答案特点：最大化其中最小值（最小化其中最大值）多源bfs？最小化最远距离（对于状态而言） https://vjudge.net/contest/237325#problem/D（）先打两个模板压压惊，去洛谷啊 E dij+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const LL INF = LL(1)&lt;&lt;50;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=500010;struct node&#123; int x; LL val; bool operator &lt; (const node&amp;a)const &#123; return val&gt;a.val; &#125;&#125;;vector&lt;node&gt; G[N];int vis[N];LL dis[N];int n,m,x;int mz;bool Dij(LL lim)&#123; clr(vis,0); for(int i=0;i&lt;=n;i++) dis[i]=INF; priority_queue&lt;node&gt; q; dis[1]=0; q.push(node&#123;1,0&#125;); node tmp; while(!q.empty()) &#123; tmp=q.top(); q.pop(); int u=tmp.x; if(vis[u]) continue; vis[u]=1; for(auto nd:G[u]) &#123; int v=nd.x; LL cost=nd.val; if(cost &gt; lim) continue; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; q.push(node&#123;v,dis[v]&#125;); &#125; &#125; &#125; if(dis[n]&lt;=mz) return true; return false;&#125;void showg()&#123; for(int i=1;i&lt;=n;i++)&#123; for(auto v:G[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.val; cout&lt;&lt;endl; &#125;&#125;int main()&#123; fastin cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=0,u,v;i&lt;m;i++)&#123; LL dis; cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis; G[u].push_back (node&#123;v,dis&#125;); G[v].push_back (node&#123;u,dis&#125;); &#125; Dij(1e7); mz=dis[n]*(1.0+x/100.0); LL l=0,r=INF; while(r-l&gt;1)&#123; LL mid=l+(r-l)/2; if( Dij(mid) ) r=mid; else l=mid; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; J 二分图匹配+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=5010;const int M=50010;vector&lt;int&gt; G[N];int link[N],used[N];int n,m;int uN;bool dfs(int u)&#123; for(auto v:G[u]) &#123; if(!used[v]) &#123; used[v]=1; if(link[v]==-1||dfs(link[v])) &#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res=0; memset(link,-1,sizeof link); for(int u=1; u&lt;=uN; u++) &#123; clr(used,0); if(dfs(u)) res++; &#125; return res;&#125;int dis[110][110];bool judge(int lim)&#123; for(int i=0; i&lt;=n; i++) G[i].clear(); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(dis[i][j]&lt;=lim) &#123; G[i].pb(j+n); G[j+n].pb(i); &#125; return hungary()==n;&#125;int xx[240];int yy[240];int main()&#123; fastin cin&gt;&gt;n; uN=n; for(int i=1; i&lt;=2*n; i++) &#123; cin&gt;&gt;xx[i]&gt;&gt;yy[i]; &#125; for(int i=1; i&lt;=n; i++) for(int j=n+1; j&lt;=2*n; j++) dis[i][j-n] = abs(xx[i]-xx[j])+abs(yy[i]-yy[j]); int l=0,r=1e8; while(r-l&gt;1) &#123; int mid=l+(r-l)/2; if(judge(mid)) r=mid; else l=mid; //cout&lt;&lt;mid&lt;&lt;endl; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; 二分答案题感觉都是00000000000001111111111111111111（求第一个1）或11111111111111110000000000000000（求第一个0）而不能解决 类似于0111111000011111000011111000000（求第一个0）记住就好了 G大意：有多个点，对于每个点，给定它的坐标和曼哈顿半径，求有几个交点0个就impossible 1就输出那个交点 2就uncertain最多 4e61+1e6 1000好气啊 当时都想出来了 复杂度推错了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;struct node&#123; int x,y; bool operator&lt; (const node&amp;a)const &#123; return x&lt;a.x; &#125;&#125;;vector&lt;node&gt; st[2];int main()&#123; fastin int n;cin&gt;&gt;n; int x,y,dis;cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(int i=-dis;i&lt;=dis;i++)&#123; st[0].push_back(node&#123;x+i,y+dis-abs(i)&#125;); if(i!=-dis &amp;&amp; i!= dis) st[0].push_back(node&#123;x+i,y-dis+abs(i)&#125;); &#125; int flag=1; for(int i=1;i&lt;n;i++)&#123; st[flag].clear(); cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(auto v:st[1^flag]) if(abs(x-v.x)+abs(y-v.y)==dis) st[flag].push_back(node&#123;v.x,v.y&#125;); flag^=1; &#125; flag^=1; /* for(int i=0;i&lt;2;i++)&#123; for(auto v:st[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.y&lt;&lt;endl; cout&lt;&lt;endl; &#125; */ if(st[flag].size()==1) cout&lt;&lt;st[flag][0].x&lt;&lt;" "&lt;&lt;st[flag][0].y&lt;&lt;endl; else if(st[flag].size()==0) puts("impossible"); else puts("uncertain"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2018%2F07%2F16%2FLCS%2F</url>
    <content type="text"><![CDATA[给出两个串 ，输出最长公共子序列学习地址：https://blog.csdn.net/zhijianshafeiyang/article/details/45034853 “用一个数组将第一个串内元素在第二个串内的位置保存下来，求这个数组的最长上升子序列长度”什么叫第一个串内元素在第二个串内的位置？比如 str1 = avbasx str2 = abcaszx 位置是反序 就是 4，1——2——4，1——5——7eg2： aaba abaa 4 3 1 —— 4 3 1—— 2 —— 4 3 1 两个问题 1.记录位置 2.位置的反序 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100000;//---------------int ans[MAX];vector&lt;int&gt; a;int LIS()&#123; int len=1; ans[0]=a[0]; for(int i=1;i&lt;a.size();i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++] = a[i]; else *lower_bound(ans,ans+len,a[i]) = a[i]; &#125; return len;&#125;//--int a1[MAX],a2[MAX];int LCSlen1,LCSlen2;int LCS()&#123; map&lt;int,int&gt; pos; a.clear(); for(int i=0;i&lt;LCSlen1;i++)&#123; pos[a1[i]] = i; &#125; for(int i=0;i&lt;LCSlen2;i++)&#123; if(pos.find(a2[i])!=pos.end()) a.pb(pos[a2[i]]); &#125; return LIS();&#125; 区域赛更新1234567891011121314int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716 SHU暑期集训个人赛(3)===]]></title>
    <url>%2F2018%2F07%2F16%2F%3D%3D%3D20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B(3)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[垫底之旅2016-2017 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2016) 看的题 但没做出来 感觉都在能力范围之内 就是没想到 A倒跑并查集也蛮难写的 也要把一个点hash成一个值 就是二维变一维嘛这 怎么想的到 Btire树上的bfstire树都不知道是是什么 你让我怎么做 C对一副乱序的扑克牌求排有序的最小_交换相邻元素的_操作个数首先数据规模很小 （最多52张牌嘛）先想想最暴力的做法咯 就对于给定的一副牌排序的结果无非是 4!（花色全排列）*2^4（顺序和倒序）种结果 384例如样例12h Th 8c Qh所有的可能性 1.2h Th Qh 8c 2.8c 2h Th Qh还有倒序的，不写了那验证每一种初态到给定态的检查的方法复杂度要多少啊？不知道啊 卡住了啊 看题解。。。怎么就LCS了拉 我怎么不知道什么意思啊？那就考虑一个更简单的模型一串乱序的数字序列 需要相邻元素交换几次才能变为不下降序列？额 不需要相邻元素 随便交换 又读错题了。。。。Sorting is done by moving one card at a time fromits current position to a new position in the hand, atthe start, end, or in between two adjacent cards. Whatis the smallest number of moves required to sort agiven hand of cards?枚举4！种排列组合 和2^4 正序 倒序 暴力求解求出最大的LCS就可以拉有个小tips：A是王牌 是最大的。。。。wa了好几发 读题读题看错题太蠢了 F推公式 排列组合题 ，没什么难度 但我推不出 H见过一道差不多的，没去写，亏了。找了半个小时没找到 算了。额 我错了 看了那么久 还是看不懂抄一遍代码 找感觉吧额 又看了一遍题目。知道了，感觉有意思。大意是：给n个矩形，让他们一个一个往上叠，约束条件是 宽严格递减（矩形可以旋转，所以长宽可以交换），求最大高度。（n个矩形都要用到）1，建图。当时第一步都没想到，鬼知道要长宽相连建图啊，但其实应该知道，这已经不是第一次遇到了。（第二次）建图前想一想，该怎么建图，如果单纯相连，那图的意义，边的意义，点的意义是什么？这里主要是边的意义,认为规定 a-&gt;b的有向边是这个矩形啊 a为宽，b为高放置。（鬼才想的到，我想不到。）利用约束条件有对这个图产生了新的限制：一个点最多一个出度（这个点只能做一次宽）这个图可能有许多连通分支，就挑一个来看，这个连通分支有什么特点2，已知：输入保证n个矩形能叠起来那上界，n个点是不是最多n条边？ 额，不知道。证明一下咯，如果有n+1条边，至少一个点的出度&gt;=2.有n条边，那连通分支中有一个环，再加一条边，又多一个环，就是说，n+1条边的无向图中有两个环一个环已经自给自足了，没法有出度的边了，那只能别人进去，有两个别人需要进去的点（环缩点），那势必有一个点需要出度两次。===\1.png) 所以n个点的连通分支最多只有n条边。 考虑下界，n个点的连通分支最少有n-1条边（一棵树，真的不能再少了，再少就两个连通分支了。。。）所以只有两种情况，n个点n条边，每个点都出度一次n个点n-1条边，有一个点无需出（哪个点不用做宽啊，哪肯定是值最大的那个啊，给我滚去做高啊） 那怎么写啊。。。。。额 抄一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int N = 5e5;vector&lt;int&gt;G[N];int val[N];int vis[N];int sz=0;int maxv,deg;LL ans=0;map&lt;int,int&gt; id;void dfs(int u)&#123; vis[u]=1; deg+=G[u].size()-2; //妙啊 一条边贡献两个度数，要是树的话，只有2n-2个总度数 ans+=LL(val[u])*(G[u].size()-1); maxv=max(maxv,val[u]); //维护最大点 for(auto v:G[u])&#123; if(!vis[v]) dfs(v); &#125;&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=0,x,y;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(id.find(x)==id.end()) id[x]=++sz,val[sz]=x; //缩点 if(id.find(y)==id.end()) id[y]=++sz,val[sz]=y; G[id[x]].pb(id[y]); G[id[y]].pb(id[x]); &#125; clr(vis,0); ans=0; for(int i=1;i&lt;=sz;i++)&#123; if(!vis[i]) &#123; maxv=0,deg=0; dfs(i); if(deg!=0) ans+=maxv; //是个树加上最大的那个点 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>倒跑</tag>
        <tag>字典树</tag>
        <tag>排列组合</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180619 SHU暑期集训个人赛(1)]]></title>
    <url>%2F2018%2F06%2F19%2F%3D%3D%3D20180619SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E4%B8%AA%E4%BA%BA%E8%B5%9B(1)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[A - Subarrays BeautyGym - 101532A 找规律 注意位运算 多半是对位的找规律 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[100010];LL b[100010];int n;LL func(LL x)&#123; return x*(x+1)/2;&#125;LL coun()&#123; LL num=0; LL ans=0; for(int i=0;i&lt;n;i++)&#123; if(num&gt;0&amp;&amp;b[i]==0) &#123; ans+=func(num);num=0; &#125; if(b[i]==1) num++; &#125; ans+=func(num); return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);LL _max=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]);_max=max(_max,a[i]); &#125; int wei=log2(_max); wei+=2; LL ans=0; LL basic=1; for(int i=0;i&lt;wei;i++,basic&lt;&lt;=1)&#123; for(int j=0;j&lt;n;j++)&#123; b[j]= a[j]&amp;1; a[j]&gt;&gt;=1; &#125; ans+=basic*coun(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;/*237 11 9411 9 6 11*/ B - Array Reconstructing Gym - 101532B 简单题 我都记不清是什么题了 多半是尝试 打印答案 //想起华师的第二道题 妈的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[1010];int n;void print_ans(int x,LL val,LL m)&#123; for(int i=x+1;i&lt;n;i++)&#123; a[i]=(a[i-1]+1)%m; &#125; for(int i=x-1;i&gt;=0;i--)&#123; a[i]=(a[i+1]-1+m)%m; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; LL m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]!=-1) &#123;print_ans(i,a[i],m);break;&#125; &#125; return 0;&#125;/*45 101 2 3 4 54 107 -1 9 -16 75 -1 -1 1 2 36 105 -1 7 -1 9 0*/ C - Large Summation Gym - 101532C二分 没什么特殊的 没接触过罢了lower_bound() &gt;=upper_bound() &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;struct node&#123; int no; int val; int ans;&#125;;int n;node a[200100];bool cmp1(node a,node b)&#123; return a.val&lt;b.val;&#125;bool cmp2(node a,node b)&#123; return a.no&lt;b.no;&#125;int findkey(int val,int pos)&#123; int l=0,r=n-1; int mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(a[mid].val&gt;val) r=mid-1; else l=mid+1; &#125; if(r==pos) r--; if(r&lt;0) return a[(pos+1)%n].val; return a[r].val;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123;cin&gt;&gt;a[i].val;a[i].no=i;&#125; sort(a,a+n,cmp1); for(int i=0;i&lt;n;i++)&#123; int ans1; if(i==n-1) ans1=(a[n-2].val+a[n-1].val)%mod; else ans1=(a[n-1].val+a[i].val)%mod; int tmp=findkey(mod-a[i].val-1,i); int ans2=(a[i].val+tmp)%mod; a[i].ans=max(ans1,ans2); &#125; sort(a,a+n,cmp2); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i].ans&lt;&lt;" "; cout&lt;&lt;a[n-1].ans&lt;&lt;endl; &#125; return 0;&#125;/*331 2 321000000000 10000000003500000007 500000002 500000003*/ D - Counting Test Gym - 101532D 预处理+查询注意l-r可以处理为 (1~r) - (1~l-1) 简单好多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[10010][26];char tmp;LL func(LL s,LL e)&#123; if(s==0) return a[e][tmp-'a']; return a[e][tmp-'a']-a[s-1][tmp-'a'];&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); memset(a,0,sizeof a); string s;cin&gt;&gt;s; a[0][s[0]-'a']++; for(int i=1;i&lt;n;i++)&#123; int num=s[i]-'a'; a[i][num]++; for(int j=0;j&lt;26;j++) a[i][j]+=a[i-1][j]; &#125; for(int i=0;i&lt;m;i++)&#123; LL ans=0; LL l,r;scanf("%lld %lld %c",&amp;l,&amp;r,&amp;tmp); l-=1;r-=1; if(r-l&lt;n)&#123; r%=n,l%=n; if(r&gt;=l) ans+=func(l,r); else&#123; ans+=func(l,n-1); ans+=func(0,r); &#125; &#125; else&#123; LL len1=r%n,len2=n-l%n; ans+=func(l%n,n-1); ans+=func(0,r%n); ans+=(r-l-len1-len2) / n * a[n-1][tmp-'a']; &#125; printf("%lld\n",ans); &#125; &#125;&#125;/*18 5abcabdca1 1 c1 15 b4 9 a5 25 d2 7 c*/ E - Game of Dice Gym - 101532E折半查找 第一次做 还可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const double eps = 1e-6;LL a[500][7];map&lt;LL,int&gt; c;int n;LL m;LL res=0;long long quickmod(long long a,long long b,long long m)&#123; long long ans = 1; while(b)&#123; if(b&amp;1)&#123; ans = (ans*a)%m;b--; &#125; b/=2; a = a*a%m; &#125; return ans;&#125;void dfs1(int cur,int e,LL ans)&#123; if(cur==e)&#123; ++c[ans]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs1(cur+1,e,(ans*a[cur][i])%mod); &#125;&#125;void dfs2(int cur,int e,LL ans)&#123; if(cur==e)&#123; res+=c[(m*quickmod(ans,mod-2,mod))%mod]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs2(cur+1,e,(ans*a[cur][i])%mod); //SDUSHADJKASDNJKASDHJK &#125;&#125;void init()&#123; res=0; c.clear();&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d %lld",&amp;n,&amp;m); init(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;6;j++) scanf("%lld",&amp;a[i][j]); int mid=n/2; dfs1(0,mid,LL(1)); dfs2(mid,n,LL(1)); cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; F - Strings and Queries Gym - 101532F 1.hash2.暴力枚举回文子串数量3.st处理区间问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int func(char s[])&#123; LL ans=0; int n=strlen(s); for(int i=0; i&lt;n; i++) &#123; for(int len=1; len&lt;n; len++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len]) ans++; else break; &#125; &#125; for(int i=0; i&lt;n-1; i++) if(s[i+1]==s[i]) &#123; ans++; for(int len=1; len&lt;n; i++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len+1]) ans++; else break; &#125; &#125; return ans;&#125;int c[40][40];int func1(string s)&#123; int len=s.size(); int sum=0; memset(c,0,sizeof c); for(int i=len-1; i&gt;=0; i--) &#123; c[i][i]=true; sum++; for(int j=i+1; j&lt;len; j++) &#123; if(s[i]==s[j]) &#123; if(i+1==j||c[i+1][j-1]) &#123; c[i][j]=true; sum++; &#125; &#125; else c[i][j]=false; &#125; &#125; return sum;&#125;LL Hash(string s)&#123; LL ans=0; int len=s.size(); for(int i=0; i&lt;len; i++) &#123; ans=ans*31+s[i]-'a'+1; &#125; return ans;&#125;struct node&#123; int no; int val; node(int n=0,int v=0) &#123; no=n; val=v; &#125; bool operator &lt; (const node&amp; a) const &#123; if(val==a.val) return no&gt;a.no; return val&lt;a.val; &#125;&#125;;char s[40];int n;node dp[10100][40];void st()&#123; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;node RMQ(int l,int r)&#123; int k=log2(r-l+1); return max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; map&lt;LL,int&gt; mp; int q; scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s); int num=func1(s); LL hs=Hash(s); mp[hs]=i; dp[i][0]=node(i,num); &#125; st(); for(int i=1; i&lt;=q; i++) &#123; char tmp1[40],tmp2[40]; scanf("%s",tmp1); scanf("%s",tmp2); LL hs1=Hash(tmp1),hs2=Hash(tmp2); int n1=mp[hs1],n2=mp[hs2]; if(n1&gt;n2) swap(n1,n2); printf("%d\n",RMQ(n1,n2).no); &#125; &#125; return 0;&#125;int main1()&#123; cout&lt;&lt;Hash("aaaa")&lt;&lt;endl; cout&lt;&lt;Hash("aaaaa")&lt;&lt;endl;&#125;/*35 5aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbcccaaaaccccaaaaaaaaaaaaaaaaccccccacccccc aaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa cccaaaaccccaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaacccccc aaaaaaaaaaaaa*/ G - Magical Indices Gym - 101532G 前缀 后缀 签到题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;int a[1000100];int maxtou[1000100];int minwei[1000100];int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i==0) maxtou[0]=a[0]; else maxtou[i]=max(maxtou[i-1],a[i]); &#125; minwei[n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--)&#123; minwei[i]=min(minwei[i+1],a[i]); &#125; int ans=0; for(int i=1;i&lt;n-1;i++)&#123; if(a[i]&lt;=minwei[i+1]&amp;&amp;a[i]&gt;=maxtou[i-1]) ans++; //cout&lt;&lt;a[i].index&lt;&lt;" "; &#125; printf("%d\n",ans); &#125; return 0;&#125;/*4101 2 1 1 1 1 1 1 1 153 3 4 5 3*/``` ## H - Corrupted Images Gym - 101532H 签到题注意角上的 唯一的坑点了吧```c++#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;char a[60][60];int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; int num=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='1') num++; &#125; if( num&lt;(2*n+2*m-4) ) &#123;cout&lt;&lt;"-1"&lt;&lt;endl;continue;&#125; int ans=0; for(int j=0;j&lt;m;j++)&#123; if(a[0][j]=='0') ans++; if(a[n-1][j]=='0') ans++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i][0]=='0') ans++; if(a[i][m-1]=='0') ans++; &#125; if(a[0][0]=='0') ans--; if(a[n-1][0]=='0') ans--; if(a[0][m-1]=='0') ans--; if(a[n-1][m-1]=='0') ans--; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; I - The Crazy Jumper Gym - 101532I dp注意下一个元素是要特殊处理 不然会超时一步步覆盖 从头想想从尾部会怎么样？12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int a[200110];int pos[200110];int dp[200110];int n;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); dp[0]=-1; memset(pos,0,sizeof pos); for(int i=1;i&lt;=n;i++)&#123; int val; scanf("%d",&amp;val); dp[i]=dp[i-1]+1; if(pos[val]!=0) dp[i]= min ( dp[i] , dp[ pos[val] ]+1); pos[val] = i ; &#125; printf("%d\n",dp[n]); &#125;&#125; J - The Hell Boy Gym - 101532J 公式 或者 递推数学问题12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9+7;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); LL ans=1,tmp; while(n--) &#123;scanf("%lld",&amp;tmp); ans=(ans*(tmp+1))%mod;&#125; printf("%lld\n",(ans+mod-1)%mod); &#125; return 0;&#125; K - Palindromes Building Gym - 101532K 组合数学123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int P[12];void pre()&#123; P[0]=1; for(int i=1;i&lt;=11;i++) P[i]=i*P[i-1];&#125;int main()&#123; pre(); int t;cin&gt;&gt;t; while(t--) &#123; int n;int l[26]; memset(l,0,sizeof l); cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char tmp;cin&gt;&gt;tmp; l[tmp-'a']++; &#125; int num=0; for(int i=0;i&lt;26;i++) if(l[i]&amp;1) num++; if(num&gt;=2)&#123; cout&lt;&lt;0&lt;&lt;endl;continue;&#125; int len=0; for(int i=0;i&lt;26;i++) &#123;l[i]/=2;len+=l[i];&#125; int ans=P[len]; for(int i=0;i&lt;26;i++) &#123;ans/=P[l[i]];&#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L - List Of Integers CodeForces - 920G 二分答案 之后容斥验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long long ll;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;void show()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;vector&lt;LL&gt; vec;LL cnum(LL r) //求1-r中与 k（不）互质 的元素的个数&#123; LL ans=0; int wei=vec.size(); for(LL i=1; i&lt;(1LL&lt;&lt;wei); i++) &#123; int bits=0,multi=1; for(LL j=0; j&lt;wei; j++) &#123; if(i&amp;(1LL&lt;&lt;j)) &#123; bits++; multi*=vec[j]; &#125; &#125; LL cur=r/multi; if(bits&amp;1) ans+=cur; else ans-=cur; &#125; //return ans; //返回与其不互质的元素个数 return r-ans;//返回与其互质的元素个数&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; LL l,no, p; scanf("%lld%lld%lld",&amp;l,&amp;p,&amp;no); vec.clear(); LL ans=0; for(LL i=2; i*i&lt;=p; i++) &#123; if(p%i==0) vec.push_back(i); while(p%i==0) p/=i; &#125; if(p&gt;1) vec.push_back(p); LL r=1e12; LL tmp=no+cnum(l); while(l&lt;=r) &#123; LL mid=l+(r-l)/2; if(cnum(mid)&gt;=tmp) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125; N - Sleepy GameCodeForces - 936B 三种简单图论知识的集合题 1.有向图 dfs判环 vis[] 标记 三种标记 0代表未访问 1代表正在访问这个分支 2代表访问完成某一分支 什么时候会形成环？ 这个点的分支在访问的时候又回到了自己这个点 蔡老师强啊 一般我会写 1234567891011121314bool huan(int u)&#123; bool flag=false; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1) return true; else if(c[v]==0)&#123; if(huan(v)) flag=true; &#125; &#125; c[u]=2; return flag;&#125; 又丑又长12345678910bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125; 对判环理解很深刻（&amp;&amp;与||优先级 不要怕 大胆写啊） 2.拆点一张图拆成两张图 偶数路径 奇数路径偶-奇-偶-。。。。。奇-偶-奇。。。一个点可能既可以在 两种情况下 都被访问 用vis[MAXN][2]全记录下来3.打印路径记录每个点在奇偶路径下的父亲 回溯输出//一开始暴力从始点枚举。。RE了多半递归炸了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int MAXN = 200100;vector&lt;int&gt; G[MAXN&lt;&lt;1];int n,m;int vis[MAXN][2];//1--到。。。可以为奇数路径int fa[MAXN][2];//0--到。。。可以为偶数路径void dfs(int s,int flag) //处理出s点的可走路径奇偶&#123; vis[s][flag]=1; for(auto v:G[s]) &#123; if(!vis[v][1-flag]) &#123; fa[v][1-flag]=s; dfs(v,1-flag); &#125; &#125;&#125;void print_ans(int u,int flag)&#123; if(u==0) &#123; return ; &#125; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;flag&lt;&lt;endl; //cout&lt;&lt;fa[u][flag]&lt;&lt;endl; print_ans(fa[u][flag],1-flag); cout&lt;&lt;u&lt;&lt;" ";&#125;void show()&#123; cout&lt;&lt;endl; cout&lt;&lt;fa[5][1]&lt;&lt;endl; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;2; j++) cout&lt;&lt;fa[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;int c[MAXN];bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof vis); for(int i=1; i&lt;=n; i++) &#123; int num; cin&gt;&gt;num; for(int j=0; j&lt;num; j++) &#123; int to; cin&gt;&gt;to; G[i].push_back(to); &#125; &#125; int s; cin&gt;&gt;s; memset(fa,0,sizeof fa); dfs(s,0); for(int i=1; i&lt;=n; i++) if(G[i].empty()&amp;&amp;vis[i][1]) &#123; cout&lt;&lt;"Win"&lt;&lt;endl; print_ans(i,1); return 0; &#125; memset(c,0,sizeof c); if(huan(s)) puts("Draw"); else puts("Lose"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>拆点</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
</search>
