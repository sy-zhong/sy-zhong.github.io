<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2018%2F12%2F05%2FLCS%2F</url>
    <content type="text"><![CDATA[给出两个串 ，输出最长公共子序列学习地址：https://blog.csdn.net/zhijianshafeiyang/article/details/45034853 “用一个数组将第一个串内元素在第二个串内的位置保存下来，求这个数组的最长上升子序列长度”什么叫第一个串内元素在第二个串内的位置？比如 str1 = avbasx str2 = abcaszx 位置是反序 就是 4，1——2——4，1——5——7eg2： aaba abaa 4 3 1 —— 4 3 1—— 2 —— 4 3 1 两个问题 1.记录位置 2.位置的反序 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100000;//---------------int ans[MAX];vector&lt;int&gt; a;int LIS()&#123; int len=1; ans[0]=a[0]; for(int i=1;i&lt;a.size();i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++] = a[i]; else *lower_bound(ans,ans+len,a[i]) = a[i]; &#125; return len;&#125;//--int a1[MAX],a2[MAX];int LCSlen1,LCSlen2;int LCS()&#123; map&lt;int,int&gt; pos; a.clear(); for(int i=0;i&lt;LCSlen1;i++)&#123; pos[a1[i]] = i; &#125; for(int i=0;i&lt;LCSlen2;i++)&#123; if(pos.find(a2[i])!=pos.end()) a.pb(pos[a2[i]]); &#125; return LIS();&#125; 区域赛更新1234567891011121314int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716 SHU暑期集训个人赛(3)===]]></title>
    <url>%2F2018%2F12%2F05%2F%3D%3D%3D20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B(3)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[垫底之旅2016-2017 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2016) 看的题 但没做出来 感觉都在能力范围之内 就是没想到 A倒跑并查集也蛮难写的 也要把一个点hash成一个值 就是二维变一维嘛这 怎么想的到 Btire树上的bfstire树都不知道是是什么 你让我怎么做 C对一副乱序的扑克牌求排有序的最小交换相邻元素的操作个数首先数据规模很小 （最多52张牌嘛）先想想最暴力的做法咯 就对于给定的一副牌排序的结果无非是 4!（花色全排列）*2^4（顺序和倒序）种结果 384例如样例12h Th 8c Qh所有的可能性 1.2h Th Qh 8c 2.8c 2h Th Qh还有倒序的，不写了那验证每一种初态到给定态的检查的方法复杂度要多少啊？不知道啊 卡住了啊 看题解。。。怎么就LCS了拉 我怎么不知道什么意思啊？那就考虑一个更简单的模型一串乱序的数字序列 需要相邻元素交换几次才能变为不下降序列？额 不需要相邻元素 随便交换 又读错题了。。。。Sorting is done by moving one card at a time fromits current position to a new position in the hand, atthe start, end, or in between two adjacent cards. Whatis the smallest number of moves required to sort agiven hand of cards?枚举4！种排列组合 和2^4 正序 倒序 暴力求解求出最大的LCS就可以拉有个小tips：A是王牌 是最大的。。。。wa了好几发 读题读题看错题太蠢了 F推公式 排列组合题 ，没什么难度 但我推不出 H见过一道差不多的，没去写，亏了。找了半个小时没找到 算了。额 我错了 看了那么久 还是看不懂抄一遍代码 找感觉吧额 又看了一遍题目。知道了，感觉有意思。大意是：给n个矩形，让他们一个一个往上叠，约束条件是 宽严格递减（矩形可以旋转，所以长宽可以交换），求最大高度。（n个矩形都要用到）1，建图。当时第一步都没想到，鬼知道要长宽相连建图啊，但其实应该知道，这已经不是第一次遇到了。（第二次）建图前想一想，该怎么建图，如果单纯相连，那图的意义，边的意义，点的意义是什么？这里主要是边的意义,认为规定 a-&gt;b的有向边是这个矩形啊 a为宽，b为高放置。（鬼才想的到，我想不到。）利用约束条件有对这个图产生了新的限制：一个点最多一个出度（这个点只能做一次宽）这个图可能有许多连通分支，就挑一个来看，这个连通分支有什么特点2，已知：输入保证n个矩形能叠起来那上界，n个点是不是最多n条边？ 额，不知道。证明一下咯，如果有n+1条边，至少一个点的出度&gt;=2.有n条边，那连通分支中有一个环，再加一条边，又多一个环，就是说，n+1条边的无向图中有两个环一个环已经自给自足了，没法有出度的边了，那只能别人进去，有两个别人需要进去的点（环缩点），那势必有一个点需要出度两次。 所以n个点的连通分支最多只有n条边。 考虑下界，n个点的连通分支最少有n-1条边（一棵树，真的不能再少了，再少就两个连通分支了。。。）所以只有两种情况，n个点n条边，每个点都出度一次n个点n-1条边，有一个点无需出（哪个点不用做宽啊，哪肯定是值最大的那个啊，给我滚去做高啊） 那怎么写啊。。。。。额 抄一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int N = 5e5;vector&lt;int&gt;G[N];int val[N];int vis[N];int sz=0;int maxv,deg;LL ans=0;map&lt;int,int&gt; id;void dfs(int u)&#123; vis[u]=1; deg+=G[u].size()-2; //妙啊 一条边贡献两个度数，要是树的话，只有2n-2个总度数 ans+=LL(val[u])*(G[u].size()-1); maxv=max(maxv,val[u]); //维护最大点 for(auto v:G[u])&#123; if(!vis[v]) dfs(v); &#125;&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=0,x,y;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(id.find(x)==id.end()) id[x]=++sz,val[sz]=x; //缩点 if(id.find(y)==id.end()) id[y]=++sz,val[sz]=y; G[id[x]].pb(id[y]); G[id[y]].pb(id[x]); &#125; clr(vis,0); ans=0; for(int i=1;i&lt;=sz;i++)&#123; if(!vis[i]) &#123; maxv=0,deg=0; dfs(i); if(deg!=0) ans+=maxv; //是个树加上最大的那个点 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180619 SHU暑期集训个人赛(1)]]></title>
    <url>%2F2018%2F12%2F05%2F%3D%3D%3D20180619SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E4%B8%AA%E4%BA%BA%E8%B5%9B(1)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[A - Subarrays BeautyGym - 101532A 找规律 注意位运算 多半是对位的找规律 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[100010];LL b[100010];int n;LL func(LL x)&#123; return x*(x+1)/2;&#125;LL coun()&#123; LL num=0; LL ans=0; for(int i=0;i&lt;n;i++)&#123; if(num&gt;0&amp;&amp;b[i]==0) &#123; ans+=func(num);num=0; &#125; if(b[i]==1) num++; &#125; ans+=func(num); return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);LL _max=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]);_max=max(_max,a[i]); &#125; int wei=log2(_max); wei+=2; LL ans=0; LL basic=1; for(int i=0;i&lt;wei;i++,basic&lt;&lt;=1)&#123; for(int j=0;j&lt;n;j++)&#123; b[j]= a[j]&amp;1; a[j]&gt;&gt;=1; &#125; ans+=basic*coun(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;/*237 11 9411 9 6 11*/ B - Array Reconstructing Gym - 101532B 简单题 我都记不清是什么题了 多半是尝试 打印答案 //想起华师的第二道题 妈的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[1010];int n;void print_ans(int x,LL val,LL m)&#123; for(int i=x+1;i&lt;n;i++)&#123; a[i]=(a[i-1]+1)%m; &#125; for(int i=x-1;i&gt;=0;i--)&#123; a[i]=(a[i+1]-1+m)%m; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; LL m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]!=-1) &#123;print_ans(i,a[i],m);break;&#125; &#125; return 0;&#125;/*45 101 2 3 4 54 107 -1 9 -16 75 -1 -1 1 2 36 105 -1 7 -1 9 0*/ C - Large Summation Gym - 101532C二分 没什么特殊的 没接触过罢了lower_bound() &gt;=upper_bound() &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;struct node&#123; int no; int val; int ans;&#125;;int n;node a[200100];bool cmp1(node a,node b)&#123; return a.val&lt;b.val;&#125;bool cmp2(node a,node b)&#123; return a.no&lt;b.no;&#125;int findkey(int val,int pos)&#123; int l=0,r=n-1; int mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(a[mid].val&gt;val) r=mid-1; else l=mid+1; &#125; if(r==pos) r--; if(r&lt;0) return a[(pos+1)%n].val; return a[r].val;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123;cin&gt;&gt;a[i].val;a[i].no=i;&#125; sort(a,a+n,cmp1); for(int i=0;i&lt;n;i++)&#123; int ans1; if(i==n-1) ans1=(a[n-2].val+a[n-1].val)%mod; else ans1=(a[n-1].val+a[i].val)%mod; int tmp=findkey(mod-a[i].val-1,i); int ans2=(a[i].val+tmp)%mod; a[i].ans=max(ans1,ans2); &#125; sort(a,a+n,cmp2); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i].ans&lt;&lt;" "; cout&lt;&lt;a[n-1].ans&lt;&lt;endl; &#125; return 0;&#125;/*331 2 321000000000 10000000003500000007 500000002 500000003*/ D - Counting Test Gym - 101532D 预处理+查询注意l-r可以处理为 (1~r) - (1~l-1) 简单好多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[10010][26];char tmp;LL func(LL s,LL e)&#123; if(s==0) return a[e][tmp-'a']; return a[e][tmp-'a']-a[s-1][tmp-'a'];&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); memset(a,0,sizeof a); string s;cin&gt;&gt;s; a[0][s[0]-'a']++; for(int i=1;i&lt;n;i++)&#123; int num=s[i]-'a'; a[i][num]++; for(int j=0;j&lt;26;j++) a[i][j]+=a[i-1][j]; &#125; for(int i=0;i&lt;m;i++)&#123; LL ans=0; LL l,r;scanf("%lld %lld %c",&amp;l,&amp;r,&amp;tmp); l-=1;r-=1; if(r-l&lt;n)&#123; r%=n,l%=n; if(r&gt;=l) ans+=func(l,r); else&#123; ans+=func(l,n-1); ans+=func(0,r); &#125; &#125; else&#123; LL len1=r%n,len2=n-l%n; ans+=func(l%n,n-1); ans+=func(0,r%n); ans+=(r-l-len1-len2) / n * a[n-1][tmp-'a']; &#125; printf("%lld\n",ans); &#125; &#125;&#125;/*18 5abcabdca1 1 c1 15 b4 9 a5 25 d2 7 c*/ E - Game of Dice Gym - 101532E折半查找 第一次做 还可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const double eps = 1e-6;LL a[500][7];map&lt;LL,int&gt; c;int n;LL m;LL res=0;long long quickmod(long long a,long long b,long long m)&#123; long long ans = 1; while(b)&#123; if(b&amp;1)&#123; ans = (ans*a)%m;b--; &#125; b/=2; a = a*a%m; &#125; return ans;&#125;void dfs1(int cur,int e,LL ans)&#123; if(cur==e)&#123; ++c[ans]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs1(cur+1,e,(ans*a[cur][i])%mod); &#125;&#125;void dfs2(int cur,int e,LL ans)&#123; if(cur==e)&#123; res+=c[(m*quickmod(ans,mod-2,mod))%mod]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs2(cur+1,e,(ans*a[cur][i])%mod); //SDUSHADJKASDNJKASDHJK &#125;&#125;void init()&#123; res=0; c.clear();&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d %lld",&amp;n,&amp;m); init(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;6;j++) scanf("%lld",&amp;a[i][j]); int mid=n/2; dfs1(0,mid,LL(1)); dfs2(mid,n,LL(1)); cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; F - Strings and Queries Gym - 101532F 1.hash2.暴力枚举回文子串数量3.st处理区间问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int func(char s[])&#123; LL ans=0; int n=strlen(s); for(int i=0; i&lt;n; i++) &#123; for(int len=1; len&lt;n; len++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len]) ans++; else break; &#125; &#125; for(int i=0; i&lt;n-1; i++) if(s[i+1]==s[i]) &#123; ans++; for(int len=1; len&lt;n; i++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len+1]) ans++; else break; &#125; &#125; return ans;&#125;int c[40][40];int func1(string s)&#123; int len=s.size(); int sum=0; memset(c,0,sizeof c); for(int i=len-1; i&gt;=0; i--) &#123; c[i][i]=true; sum++; for(int j=i+1; j&lt;len; j++) &#123; if(s[i]==s[j]) &#123; if(i+1==j||c[i+1][j-1]) &#123; c[i][j]=true; sum++; &#125; &#125; else c[i][j]=false; &#125; &#125; return sum;&#125;LL Hash(string s)&#123; LL ans=0; int len=s.size(); for(int i=0; i&lt;len; i++) &#123; ans=ans*31+s[i]-'a'+1; &#125; return ans;&#125;struct node&#123; int no; int val; node(int n=0,int v=0) &#123; no=n; val=v; &#125; bool operator &lt; (const node&amp; a) const &#123; if(val==a.val) return no&gt;a.no; return val&lt;a.val; &#125;&#125;;char s[40];int n;node dp[10100][40];void st()&#123; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;node RMQ(int l,int r)&#123; int k=log2(r-l+1); return max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; map&lt;LL,int&gt; mp; int q; scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s); int num=func1(s); LL hs=Hash(s); mp[hs]=i; dp[i][0]=node(i,num); &#125; st(); for(int i=1; i&lt;=q; i++) &#123; char tmp1[40],tmp2[40]; scanf("%s",tmp1); scanf("%s",tmp2); LL hs1=Hash(tmp1),hs2=Hash(tmp2); int n1=mp[hs1],n2=mp[hs2]; if(n1&gt;n2) swap(n1,n2); printf("%d\n",RMQ(n1,n2).no); &#125; &#125; return 0;&#125;int main1()&#123; cout&lt;&lt;Hash("aaaa")&lt;&lt;endl; cout&lt;&lt;Hash("aaaaa")&lt;&lt;endl;&#125;/*35 5aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbcccaaaaccccaaaaaaaaaaaaaaaaccccccacccccc aaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa cccaaaaccccaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaacccccc aaaaaaaaaaaaa*/ G - Magical Indices Gym - 101532G 前缀 后缀 签到题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;int a[1000100];int maxtou[1000100];int minwei[1000100];int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i==0) maxtou[0]=a[0]; else maxtou[i]=max(maxtou[i-1],a[i]); &#125; minwei[n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--)&#123; minwei[i]=min(minwei[i+1],a[i]); &#125; int ans=0; for(int i=1;i&lt;n-1;i++)&#123; if(a[i]&lt;=minwei[i+1]&amp;&amp;a[i]&gt;=maxtou[i-1]) ans++; //cout&lt;&lt;a[i].index&lt;&lt;" "; &#125; printf("%d\n",ans); &#125; return 0;&#125;/*4101 2 1 1 1 1 1 1 1 153 3 4 5 3*/``` ## H - Corrupted Images Gym - 101532H 签到题注意角上的 唯一的坑点了吧```c++#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;char a[60][60];int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; int num=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='1') num++; &#125; if( num&lt;(2*n+2*m-4) ) &#123;cout&lt;&lt;"-1"&lt;&lt;endl;continue;&#125; int ans=0; for(int j=0;j&lt;m;j++)&#123; if(a[0][j]=='0') ans++; if(a[n-1][j]=='0') ans++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i][0]=='0') ans++; if(a[i][m-1]=='0') ans++; &#125; if(a[0][0]=='0') ans--; if(a[n-1][0]=='0') ans--; if(a[0][m-1]=='0') ans--; if(a[n-1][m-1]=='0') ans--; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; I - The Crazy Jumper Gym - 101532I dp注意下一个元素是要特殊处理 不然会超时一步步覆盖 从头想想从尾部会怎么样？12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int a[200110];int pos[200110];int dp[200110];int n;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); dp[0]=-1; memset(pos,0,sizeof pos); for(int i=1;i&lt;=n;i++)&#123; int val; scanf("%d",&amp;val); dp[i]=dp[i-1]+1; if(pos[val]!=0) dp[i]= min ( dp[i] , dp[ pos[val] ]+1); pos[val] = i ; &#125; printf("%d\n",dp[n]); &#125;&#125; J - The Hell Boy Gym - 101532J 公式 或者 递推数学问题12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9+7;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); LL ans=1,tmp; while(n--) &#123;scanf("%lld",&amp;tmp); ans=(ans*(tmp+1))%mod;&#125; printf("%lld\n",(ans+mod-1)%mod); &#125; return 0;&#125; ##K - Palindromes Building Gym - 101532K 组合数学123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int P[12];void pre()&#123; P[0]=1; for(int i=1;i&lt;=11;i++) P[i]=i*P[i-1];&#125;int main()&#123; pre(); int t;cin&gt;&gt;t; while(t--) &#123; int n;int l[26]; memset(l,0,sizeof l); cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char tmp;cin&gt;&gt;tmp; l[tmp-'a']++; &#125; int num=0; for(int i=0;i&lt;26;i++) if(l[i]&amp;1) num++; if(num&gt;=2)&#123; cout&lt;&lt;0&lt;&lt;endl;continue;&#125; int len=0; for(int i=0;i&lt;26;i++) &#123;l[i]/=2;len+=l[i];&#125; int ans=P[len]; for(int i=0;i&lt;26;i++) &#123;ans/=P[l[i]];&#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L - List Of Integers CodeForces - 920G 二分答案 之后容斥验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long long ll;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;void show()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;vector&lt;LL&gt; vec;LL cnum(LL r) //求1-r中与 k（不）互质 的元素的个数&#123; LL ans=0; int wei=vec.size(); for(LL i=1; i&lt;(1LL&lt;&lt;wei); i++) &#123; int bits=0,multi=1; for(LL j=0; j&lt;wei; j++) &#123; if(i&amp;(1LL&lt;&lt;j)) &#123; bits++; multi*=vec[j]; &#125; &#125; LL cur=r/multi; if(bits&amp;1) ans+=cur; else ans-=cur; &#125; //return ans; //返回与其不互质的元素个数 return r-ans;//返回与其互质的元素个数&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; LL l,no, p; scanf("%lld%lld%lld",&amp;l,&amp;p,&amp;no); vec.clear(); LL ans=0; for(LL i=2; i*i&lt;=p; i++) &#123; if(p%i==0) vec.push_back(i); while(p%i==0) p/=i; &#125; if(p&gt;1) vec.push_back(p); LL r=1e12; LL tmp=no+cnum(l); while(l&lt;=r) &#123; LL mid=l+(r-l)/2; if(cnum(mid)&gt;=tmp) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125; N - Sleepy GameCodeForces - 936B 三种简单图论知识的集合题 1.有向图 dfs判环 vis[] 标记 三种标记 0代表未访问 1代表正在访问这个分支 2代表访问完成某一分支 什么时候会形成环？ 这个点的分支在访问的时候又回到了自己这个点 蔡老师强啊 一般我会写 1234567891011121314bool huan(int u)&#123; bool flag=false; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1) return true; else if(c[v]==0)&#123; if(huan(v)) flag=true; &#125; &#125; c[u]=2; return flag;&#125; 又丑又长12345678910bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125; 对判环理解很深刻（&amp;&amp;与||优先级 不要怕 大胆写啊） 2.拆点一张图拆成两张图 偶数路径 奇数路径偶-奇-偶-。。。。。奇-偶-奇。。。一个点可能既可以在 两种情况下 都被访问 用vis[MAXN][2]全记录下来3.打印路径记录每个点在奇偶路径下的父亲 回溯输出//一开始暴力从始点枚举。。RE了多半递归炸了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int MAXN = 200100;vector&lt;int&gt; G[MAXN&lt;&lt;1];int n,m;int vis[MAXN][2];//1--到。。。可以为奇数路径int fa[MAXN][2];//0--到。。。可以为偶数路径void dfs(int s,int flag) //处理出s点的可走路径奇偶&#123; vis[s][flag]=1; for(auto v:G[s]) &#123; if(!vis[v][1-flag]) &#123; fa[v][1-flag]=s; dfs(v,1-flag); &#125; &#125;&#125;void print_ans(int u,int flag)&#123; if(u==0) &#123; return ; &#125; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;flag&lt;&lt;endl; //cout&lt;&lt;fa[u][flag]&lt;&lt;endl; print_ans(fa[u][flag],1-flag); cout&lt;&lt;u&lt;&lt;" ";&#125;void show()&#123; cout&lt;&lt;endl; cout&lt;&lt;fa[5][1]&lt;&lt;endl; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;2; j++) cout&lt;&lt;fa[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;int c[MAXN];bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof vis); for(int i=1; i&lt;=n; i++) &#123; int num; cin&gt;&gt;num; for(int j=0; j&lt;num; j++) &#123; int to; cin&gt;&gt;to; G[i].push_back(to); &#125; &#125; int s; cin&gt;&gt;s; memset(fa,0,sizeof fa); dfs(s,0); for(int i=1; i&lt;=n; i++) if(G[i].empty()&amp;&amp;vis[i][1]) &#123; cout&lt;&lt;"Win"&lt;&lt;endl; print_ans(i,1); return 0; &#125; memset(c,0,sizeof c); if(huan(s)) puts("Draw"); else puts("Lose"); return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
